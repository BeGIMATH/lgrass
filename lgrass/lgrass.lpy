# -*- coding: latin-1 -*-

from openalea.plantgl.all import * 
from openalea.mtg.io import *
from openalea.mtg.aml import *
import random
from math import *
import numpy as np
from openalea.mtg.mtg import *
import time as t
import csv
from alinea.caribu.CaribuScene import CaribuScene
from alinea.caribu.sky_tools import turtle
from copy import *

reprise_coupe=False

#param partie aerienne
C=[0.7,1.4,1.5]

# maitrise l'aléatoire
random.seed(0.4)
alea1=[random.random() for x in range(4000)]
alea1_index=[0,0,0]
alea2=[random.random() for x in range(4000)]

### parametre temps
dt=1
timing=0

### parametre scene
NBlignes=1
NBcolonnes=1
genotype=[0]


Seuil=[]#[[5.5]*(300)]*10
Tailfingain=[]
SB=[0.]*(NBlignes*NBcolonnes)
RB=[0.]*(NBlignes*NBcolonnes)
BiomProd=[0.]*(NBlignes*NBcolonnes)
Ray=[0.]*(NBlignes*NBcolonnes)
PourcentageRootGrowthRealized=[0]*(NBlignes*NBcolonnes)
Reserve=[0]*(NBlignes*NBcolonnes)
Demande_feuille=[0]*(NBlignes*NBcolonnes)
Demande_feuille_dans_gaine=[0]*(NBlignes*NBcolonnes)
Demande_feuille_hors_gaine=[0]*(NBlignes*NBcolonnes)
#Next_biom_feuil=[0]*(NBlignes*NBcolonnes)
PourcentageFeuilGrowthRealized=[1]*(NBlignes*NBcolonnes)
groupe=1 # permet de realiser les coupes.    groupe=1 : croissance     groupe=2 : coupe


SBap_recolte=0

les_diametres=[]


#definition des contours pour la sortie graphique
limbo = profilelimbe.deepcopy()
foldlimbo = profilefoldlimbe.deepcopy()
gaino = profilegaine.deepcopy()

#definition des groupes de production
Croissance = 1
Defoliation = 2

STOPTALLAGE = 110000.         #/*Parametre de surface ou fermeture couvert dans lequel tire le random pour stoper tallage*/
SENSETALLAGE =10000. #TF  =10000 #TG          
Surfoliairetotale=[0.]*(NBlignes*NBcolonnes)  # Surface folaire totale obtenu a la fin d'un pas
Surfoliaireencours=[0.]*(NBlignes*NBcolonnes) # variable de calcul de la surface foliaire totale

nb_talle=[]  # nombre_de_talle-1 pour chaque plante afin d'itendifier les talles
Premiecroiss=[110,91]


Taillepointelineraire = 5.
LSTEP = 1
Torsiongaine = 0.        #/*Angle torsion des gaines */
curve = 0.3*LSTEP              #/*Angle courbure des limbe */
INSERTIONLIMBE = 40.
divergetalle = 30.

### parametres coupe
PREMIERCOUPE=1500          #/* Date de la premiere coupe */
FREQUCOUPE=800              #/* Peridodicité coupe en °C.j */
DUREECOUPE=600000 
HCOUP=30
DCOUP=PREMIERCOUPE

#### parametre ArchiSimple
NBPASMAX=151 #/* Nombre maximal de pas de temps */
NBHORMAX=60 #/* Nombre maximal d'horizons de sol */
MAXLINE=150  #/* Longueur maxi de la ligne dans fichiers texte */
NBCASEMAX=301  #/* Nombre maximal de cases de sol en X, Y et Z */

epsilon=1.0e-10 #/* Petite valeur, proche de 0 */
epaissHor=50.0  #/* Epaisseur horizons de sol (en mm) */
longSegNorm=1.9  #/* Longueur habituelle des segments formés (mm) */
longSegMin=2.0  #/* Longueur minimale des segments formés, quand faible croissance (mm) */
dureeSansCreation=3 #/* Durée maximale sans création de noeud, quand faible croissance (jour) */
mailleMin=6.0  #/* Valeur de la maille minimale de sol (mm) */
d1=3.0   #/* Première valeur de distance (mm) */
d2=30.0  #/* Deuxième valeur de distance (plus grande) (mm) */

### parametres Racines

P_angInitMoyVertPrim=0.7854 #/* Angle d'insertion moyen par rapport à la verticale pour les primaires */
P_angInitETVertPrim=0.35  #/* écart-type de l'angle d'insertion des primaires */

#// Probabilité journalière d'arrêt de la croissance
#P_probaMaxArret=0.05  #/* Probabilité journalière d'arrêt maximale, pour un diamètre nul */
#P_probaEffetDiam=0.0000000001  #/* Effet de décroissance de la probabilité, en lien avec diamètre apical (mm-1) */

#// Croissance radiale
P_coeffCroissRad=0.0 #// coefficient de croissance radiale

#// Allongement (croissance axiale)
P_diamMin=0.04#0.07  #/* Diamètre minimal en deça duquel il n'y a pas de croissance (mm) */                                         OK #########
P_diamMax=0.5267478945#0.59*0.9#0.56*0.9 #FL  =0.47#FC     #  #/* Diamètre maximal donné aux racines primaires (mm) */                                                       OK #########  A estimer utilisation mesures de diam
P_diamVM=0.2596958466
P_elongMax=1.0333098615
P_penteVitDiam=2.212#2 #/* pente de la relation entre vitesse de croissance et diamètre (mm.mm.jour-1) */                          OK #########  A estimer utilisation rhizotrons
P_tendanceDirTropisme=2  #/* Type de tropisme (0: plagio; -1: geo-; +1: geo+; 2: exo */                                       
P_intensiteTropisme=0.05 #/* Coefficient multiplié par le diamètre pour chaque racine */                                      

#// Ramification
P_ageMaturitePointe=95 #/* âge de maturité des méristèmes (jours) */                                                           OK #########
P_distRamif=2.5  #1.8 #/* distance inter-ramification (mm) */                                                                        OK #########
P_propDiamRamif=0.25 #/* proportion de diamètre des filles par rapport à leur mère */                                          OK ######### A estimer utilisation scans
P_coeffVarDiamRamif=0.25 #/* coefficient de variation du diamètre des ramifs */                                                OK #########
P_angLat=1.3 #/* angle d'insertion des racines latérales */                                                                    


#// Mortalité
P_TMD=0.142 #=0.2 avant     /* Tissue mass density, ou masse volumique */                                                                       #########
P_penteDureeVieDiamTMD=5000.0 #/* pente de la relation durée de vie versus diamètre et TMD */                                   #########  A estimer utilisation scans

#/* Variables globales diverses */
TPS=0  #/* Le temps, en jours */
r3=[0,0,0]  #/* Position d'origine du système racinaire */

#// Relation allometrique
Alpha=[0.8372920802,0.8372920802,0.8372920802]#[0.9597,1.0285]#TF  =  #TG            
Beta=[0.3693325303,0.3693325303,0.3693325303]#[0.3650,0.4533] #TF   = #TG            
t1=[0.0047205816,0.0047205816,0.0047205816]#[0.0075102548,0.0036031235]   #     #0.0026715016]#[0.0064010594,0.0043724156]  #TF  =0.0030162134 #TG            
t2=[0.0071089808,0.0071089808,0.0071089808]#[0.0066334518,0.0069460919]   #     #0.0072314877]#[0.0068188115,0.0066758828] #TF  =0.0070523741 #TG                           
#t3=[0.0216082511,0.0171435775]  #TF  =0.00643633 #TG           

##EvolRoot
#alpha=0.897
#beta=0.234
#t2=0.007478 #FC    =0.00613 #FL               
#t3=0.005839 #FC    =0.0106 #FL                

P_RootMasseVolumique=0.142e-3 #Catherine  #=8e-5       # masse volumique des racines en g.mm-3
P_ShootMasseVolumique=1e-4   # biomass des feuilles en fonction de leur longueur en g.mm-1
#Reserve=0   # reserve de "biomass"

INPUTS_DIRPATH = 'inputs'
OUTPUTS_DIRPATH = 'outputs'
fichier_sol=open(INPUTS_DIRPATH + "/sol2.txt","rb")
tableau_sol=csv.reader(fichier_sol,delimiter='	')
Sol=[]
j=0
for x in tableau_sol:
  if j==0:
    j=1
  else:
    Sol.append(x)
fichier_sol.close()

#fichier_volrac=open("E:/Projets/ESIP/2016-2017/Plant_Model/volrac.txt","rb")
#tableau_volrac=csv.reader(fichier_volrac,delimiter='	')
#volrac=[]
#for x in tableau_volrac:
#  volrac.append(x)
#fichier_volrac.close()

uvox=([],[],[])  #/* tableau sol-voxel dont les cases vont contenir des entiers 1, 2 ou 3 */
anisotropisme=0 # en attendant le sol

maille=mailleMin #/* Valeur initialisée de la maille de sol */
volElemSol=0  #/* Volume élémentaire de sol associé à la maille (mm3) */

num_pointe=0
num_primordium=0




class ParamPlante:
  def __init__(self,id_plante=0,id_geno=0):
    self.id_plante=id_plante
    self.id_geno=id_geno

class ParamPhytomere:
  def __init__(self, id_plante = 0, id_talle = 0, id_rang = 0,age=0,  angletal = 0):#, Carbdescend = 0, Carbmonte = 0):
    self.id_plante = id_plante
    self.id_talle = id_talle
    self.id_rang = id_rang
    self.age=age
    self.angletal = angletal
#    self.Carbdescend = Carbdescend
#    self.Carbmonte = Carbmonte


class ParamFeuille:
  def __init__(self,age = 0, Agecroiss = 0, Taillefeuille = 0, id_plante = 0, id_talle = 0, id_rang = 1, Ymax= 0, Difftps=0,  Taillefinalel = 0, Taillefinaleg = 0., Taillelimbe = 0, Taillegaine = 0, Phase = 0, rapportK = 0.2, coupe = 0.,Cutstatus=0, angleinsert = 0,angletal=0., geno = 0, surface = 0, biomass=0., Besoinencroiss = 0,TailleEmergence=0.,R=0.973):
    self.age = age
    self.Agecroiss = Agecroiss
    self.Taillefeuille = Taillefeuille
    self.id_plante = id_plante
    self.id_talle = id_talle
    self.id_rang = id_rang
    self.Ymax = Ymax
    self.Difftps = Difftps
    self.Taillefinalel = Taillefinalel
    self.Taillefinaleg = Taillefinaleg
    self.Taillelimbe = Taillelimbe
    self.Taillegaine = Taillegaine
    self.Phase = Phase
    self.rapportK = rapportK                 # = rapport gaine / limbe 
    self.coupe = coupe  # ce qui a ete coupe par defoliation
    self.Cutstatus=Cutstatus                   
    self.angleinsert = angleinsert              # angle limbe*/
    self.angletal=angletal                   #angle de la talle qui ecarte la feuille                           
    self.geno = geno
    self.surface = surface
    self.biomass=biomass
    self.Besoinencroiss = Besoinencroiss
    self.TailleEmergence=TailleEmergence
    self.R=R


class ParamSegFeuille:
  def __init__(self,idLong,hauteur):
    self.idLong=idLong
    self.hauteur=hauteur

class ParamApex:
  def __init__(self,id_plante,id_talle,id_rang=1,retard=0):
    self.id_plante=id_plante
    self.id_talle=id_talle
    self.id_rang=id_rang
    self.retard=retard


class ParamApexTal:
  def __init__(self,id_plante,id_talle=0,id_rang=1,retard=0):
    self.id_plante=id_plante
    self.id_talle=id_talle
    self.id_rang=id_rang
    self.retard=retard

class ParambourgeonRoot:
  def __init__(self,id_plante,id_talle=0,id_rang=1,nb_prod_root=0):
    self.id_plante=id_plante
    self.id_talle=id_talle
    self.id_rang=id_rang
    self.nb_prod_root=nb_prod_root

class ParamRacine:
  def __init__(self,age = 0, id_plante=0 ,id_talle=0 ,id_rang=0,axe_arret=0,lateral_arret=0,feuil_ref=0):
    self.age = age
    self.id_plante=id_plante
    self.id_talle=id_talle
    self.id_rang=id_rang
    self.axe_arret=axe_arret
    self.lateral_arret=lateral_arret
    self.feuil_ref=feuil_ref

class pte:
  def __init__(self, id_pointe=0,id_plante=0, age=0, diametre=0., distPrimInit=0., longueur=0.01, profondeur=0.,dateDerniereCreation=0, posO=np.array([0.,0.,0.]),Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]), isaxe=False,arretee=False, senile=False,axe_mort=False,segment=0):
    self.id_pointe=id_pointe
    self.id_plante=id_plante
    self.age=age
    self.diametre=diametre
    self.distPrimInit=distPrimInit
    self.longueur=longueur
    self.profondeur=profondeur
    self.dateDerniereCreation=dateDerniereCreation
    self.posO=posO
    self.Tortue=Tortue
    self.isaxe=isaxe
    self.arretee=arretee
    self.senile=senile
    self.axe_mort=axe_mort
    self.segment=segment


class primord:
  def __init__(self,id_primord,age,diametre,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]),avorte=False,id_pointe_axe=0,posO=np.array([0.,0.,0.])):
    self.id_primord=id_primord
    self.age=age
    self.diametre=diametre
    self.Tortue=Tortue
    self.avorte=avorte
    self.id_pointe_axe=id_pointe_axe
    self.posO=posO

class seg:
  def __init__(self, jourForm,diametre,longueur=0.,id_pointe_axe=0):
    self.jourForm=jourForm
    self.diametre=diametre
    self.longueur=longueur
    self.id_pointe_axe=id_pointe_axe

#########   definition sol   #########

class Horizon:  #/* Horizon de sol */
  def __init__(self,croiss,ramif,iCMeca,oCMeca):
    self.croiss  #/* Coefficient de croissance, compris entre 0 et 1 */
    self.ramif  #/* Coefficient multiplicateur de distance inter-ramif  */
    self.iCMeca  #/* Intensité de la contrainte mécanique */
    self.oCMeca    #/* Orientation de la contrainte mécanique (O iso, ou 1 vert) */

module CouvertVegetal : scale=1
module Plante(ParamPlante) : scale=2
module phytomere(ParamPhytomere) : scale=3
module Entrenoeud : scale=4
module Feuille(ParamFeuille) : scale=4
module SegFeuille(ParamSegFeuille) : scale=5
module apex(ParamApex) : scale=4
module ApexTal(ParamApexTal) : scale=4
module bourgeonRoot(ParambourgeonRoot) : scale=4
module racine(ParamRacine) : scale=4
module segment(seg) : scale=5
module tip(pte) : scale=5
module Site(primord) : scale=5
module IN
module FLW

scales={}
parameters={}

scales['CouvertVegetal']=1
parameters['CouvertVegetal']=[]

scales['Plante']=2
parameters['Plante']=['ParamPlante']

scales['phytomere']=3
parameters['phytomere']=['ParamPhytomere']

scales['Entrenoeud']=4
parameters['Entrenoeud']=[]

scales['Feuille']=4
parameters['Feuille']=['ParamFeuille']

scales['SegFeuille']=5
parameters['SegFeuille']=['ParamSegFeuille']

scales['apex']=4
parameters['apex']=['ParamApex']

scales['ApexTal']=4
parameters['ApexTal']=['ParamApexTal']

scales['bourgeonRoot']=4
parameters['bourgeonRoot']=['ParambourgeonRoot']

scales['racine']=4
parameters['racine']=['ParamRacine']

scales['segment']=5
parameters['segment']=['seg']

scales['tip']=5
parameters['tip']=['pte']

scales['Site']=5
parameters['Site']=['primord']


sous_mtg=[False,False,False,True,False]   #indique quels sont les échelle sous-mtg de l'échelle precedente
TREE=[False,False,True,False,True]
TPS=0.

def apply_caribu(lstring, lscene, ligthsources):
  
  c_scene = CaribuScene()#pattern=r'D:\vincent\racines\L-py\2014\janvier\Pattern.8')   
  idmap = c_scene.add_Shapes(lscene)
  
  c_scene.addSources(ligthsources)
  
  output = c_scene.runCaribu(infinity=False)
  
  if c_scene.output_by_id(output, idmap)<>{}:
    c_res = c_scene.output_by_id(output, idmap)['Eabs']
  else:
    return {}
  
  #print('phase3',t.time()-timing1)
  
  for id,v in c_res.items():
    # A Adapter en fonction du nom des modules, des parametres, ...
    if lstring[id].name == 'Mon Module':
      lstring[id].p.caribulight = v
  
  return c_res

def my_axialtree2mtg(tree, scale, scene, parameters, TREE=[]):
  #print(scene)
  def scene_id(scene):
    d = {}
    if scene:
      for sh in scene:
        d.setdefault(sh.id,[]).append(sh)
      return d
  
  def change_id(axial_id, mtg_id):
    if geoms:
      if geoms.has_key(axial_id):
        for shape in geoms[axial_id]:
          shape.id = mtg_id
          mtg.property('geometry')[mtg_id]=geoms[axial_id]
      else:
        # 'Be careful : no id ', axial_id
        pass
    
    # The string represented by the axial tree...
    
  nombre=0 
  nombre2=0
  symbols=['IN','FLW','[',']']
  
  geoms = scene_id(scene)
  mtg = MTG()
  if scene:
    mtg.add_property('geometry')
  
  if parameters is None:
    parameters = {}
  for label in parameters:
    for p in parameters[label]:
      if p not in mtg.property_names():
        mtg.add_property(p)
  
  vid = mtg.root
  current_vertex = vid
  branching_stack = [vid]
  pending_edge = '' # edge type for the next edge to be created
  
  indoor=0
  follow=0
  
  
  
  for aid, modul in enumerate(tree):
    label = modul.name
    
    if (label not in scale)and(label not in symbols):
      continue
    elif label =='IN':
      indoor=1
      
    elif label=='FLW':
      follow=1
      
    elif label == '[':
      if indoor==0 and follow==0:
        
        branching_stack.append(current_vertex)
        pending_edge = '+'
      elif indoor==1:
        indoor=0
      else:
        follow==0
      
    elif label == ']':
      if indoor==0 and follow==0 and branching_stack!=[0]:
        current_vertex = branching_stack.pop()
        pending_edge = ''
      elif indoor==1:
        indoor=0
      else:
        follow=0
        
    else:
      nombre=nombre+1
      _scale = scale[label]
      _params = parameters.get(label, [])
      
      params = {}
      params['label'] = label
      for p in _params:
        if modul.hasParameter(p):
          params[p] = modul.getParameter(p)
          
      
      
      if _scale==mtg.scale(current_vertex)+1:
        current_vertex = mtg.add_component(current_vertex, **params)
        if _scale==5:
          indoor=0
          follow=0
        nombre2=nombre2+1
        
      
      elif mtg.scale(current_vertex) == _scale:
        # Add a vertex at the finer scale
        if pending_edge == '+':
          edge_type = '+'
        else:
          edge_type = '<'
        params['edge_type'] = edge_type
        current_vertex = mtg.add_child(current_vertex, **params)
        pending_edge=''
        nombre2=nombre2+1
        
      elif mtg.scale(current_vertex) > _scale:
        if TREE[_scale-1]==False:
          params['edge_type']=''
        else:
          if pending_edge=='+':
            edge_type = '+'
          else:
            edge_type = '<'
          params['edge_type'] = edge_type
          
        while mtg.scale(current_vertex) > _scale:
          current_vertex=mtg.complex(current_vertex)
        
        current_vertex = mtg.add_child(current_vertex, **params)
        vid = current_vertex
        pending_edge=''
        nombre2=nombre2+1
      
      
      if label=='Feuille' or _scale==len(TREE)-1:
        change_id(aid,current_vertex)
  
  mtg = fat_mtg(mtg)
  
  return mtg

def LongueurFeuilleCoupee(vtx_feuille):
  global mtg
  
  for x in Components(vtx_feuille):
    #print(mtg.property('ParamSegFeuille').get(x).hauteur)
    if mtg.property('ParamSegFeuille').get(x).hauteur>HCOUP:
      return mtg.property('ParamSegFeuille').get(x).idLong
  return -1

def Gravitropisme(vertex,segment,profondeur,elong,init):#age,ordre,Turtle):
  global AngleMaxInit,mtg
  
  Tortue=mtg.property('pte').get(vertex).Tortue
  if (Order(vertex)==0 and segment==0 and init==1):# idem a (age==0 and ordre==0) signifie 1ere croissance de la racine
    alpha=pi
    while alpha> (pi/2):
      alpha=random.normalvariate(P_angInitMoyVertPrim,P_angInitETVertPrim)
    beta=random.random()*2*pi 
  
  elif (segment==0 and init==1):# idem a age=0 signifie 1ere croissance d'une laterale
    alpha=P_angLat
    beta=random.random()*2*pi
  
  else:  
    
    #### vect direction pointe ####
    tortue=np.array([Tortue[:,0]])/np.linalg.norm(Tortue[:,0])
    
    #### vect gravitropisme ####
    G=np.array([0,0,-P_intensiteTropisme*elong*mtg.property('pte').get(vertex).diametre])
    
    #### vect meca  ###
    
    #Dx=random.random()*2-1
    #sign=(floor(random.random()*2))*2-1
    #Dy=sign*sin(acos(Dx))
    #Meca=0.5*(Dx*np.array([Tortue[:,1]]/np.linalg.norm(Tortue[:,1]))+Dy*np.array([Tortue[:,2]]/np.linalg.norm(Tortue[:,2])))
    
    
    cont=float(Sol[Couche(profondeur)][2])
    if Sol[Couche(profondeur)][3]==1:##(oCMecaSol(sol,profondeur)==1)  /* Contrainte anisotrope verticale */
      ## on est dans le cas ou le sol est composé de nombreux tunnel verticaux de vers de terre qui entraine une orientation assez verticale des racines 
      teta=15*pi/180
      ang_insertion=random.random()*2*teta-teta
      ang_radial=random.random()*2*pi
      RotLeft=np.array([[1,0,0],[0,cos(ang_radial),-sin(ang_radial)],[0,sin(ang_radial),cos(ang_radial)]])
      RotUp=np.array([[cos(ang_insertion),sin(ang_insertion),0],[-sin(ang_insertion),cos(ang_insertion),0],[0,0,1]])
      Rot=np.dot(Tortue,RotLeft)
      Meca=np.dot(Rot,RotUp)/np.linalg.norm(Meca[:,0])*elong *cont
    else:
      ang_insertion=random.random()*pi-pi/2
      ang_radial=random.random()*2*pi
      RotLeft=np.array([[1,0,0],[0,cos(ang_radial),-sin(ang_radial)],[0,sin(ang_radial),cos(ang_radial)]])
      RotUp=np.array([[cos(ang_insertion),sin(ang_insertion),0],[-sin(ang_insertion),cos(ang_insertion),0],[0,0,1]])
      Rot=np.dot(Tortue,RotLeft)
      Meca=np.dot(Rot,RotUp)
      Meca=Meca[:,0]/np.linalg.norm(Meca[:,0])
      Meca=Meca*elong*cont
    ### vect final ###
    newtortue=tortue+G+Meca
    newtortue=newtortue/np.linalg.norm(newtortue)
    A=np.array([0.,0.,0.])
    for i in xrange(3):
      a=np.array([Tortue[0,:],Tortue[1,:],Tortue[2,:]])
      a[:,i]=newtortue
      A[i]=np.linalg.det(a)/float(np.linalg.det(Tortue))
    
    A=A/np.linalg.norm(A)
    alpha=acos(A[0])
    beta=acos(-A[1]/sin(alpha))
    
    if ((A[2] <0 and -sin(alpha)*sin(beta)>0) or (A[2] >0 and -sin(alpha)*sin(beta)<0)) :
      beta=-beta
    
    
    
  RotLeft=np.array([[1,0,0],[0,cos(beta),-sin(beta)],[0,sin(beta),cos(beta)]])
  RotUp=np.array([[cos(alpha),sin(alpha),0],[-sin(alpha),cos(alpha),0],[0,0,1]])
  Rot=np.dot(Tortue,RotLeft)
  newTurtle=np.dot(Rot,RotUp)
  #newTurtle[:,0]=newTurtle[:,0]/np.linalg.norm(newTurtle[:,0])
  
  pos=mtg.property('pte').get(vertex).posO
  newpos=pos+newTurtle[:,0]*elong
  return (newTurtle,newpos)


def CroissanceRacine(X,profondeur):
  c=Couche(profondeur)
  return (X.diametre - P_diamMin)* dt * P_penteVitDiam * float(Sol[Couche(profondeur)][0])
#  return P_elongMax*(1+(max(0,(P_diamMax-X.diametre))/(P_diamMax-P_diamVM)))*pow((min(1,(X.diametre-P_diamMin)/(P_diamMax-P_diamMin))),((P_diamMax-P_diamMin)/(P_diamMax-P_diamVM)))

def CroissanceRacine2(X,profondeur):
  c=Couche(profondeur)
  if X.diametre>P_diamMax:
    return P_elongMax
  else:
    return P_elongMax*(1+(max(0,(P_diamMax-X.diametre))/(P_diamMax-P_diamVM)))*pow((min(1,(X.diametre-P_diamMin)/(P_diamMax-P_diamMin))),((P_diamMax-P_diamMin)/(P_diamMax-P_diamVM)))

def tireDiamPointeFille(diametre_pere):
  ##/* Tire le diamètre d'un méristème de ramification suivant celui du père
  ##   pour la ramification séquentielle */
  
  moy=diametre_pere*P_propDiamRamif #+ (P_diamMin*(1.0-P_propDiamRamif))
  et=moy*P_coeffVarDiamRamif
  diamPFille=10.0 #// initialisation à une forte valeur
  while (diamPFille>(1.1*diametre_pere)):
     diamPFille=random.normalvariate(moy,et)
  return diamPFille


def Distance(v1,v2):  
  dist=0
  chemin=Path(v1,v2)
  chemin.append(v1)
  for x in chemin:
    if Class(x)=='s':
      geo=g.property('geometry').get(x)[0]
      points=geo.geometry.axis.pointList
      long=sqrt((points[0][0]-points[1][0])**2+(points[0][1]-points[1][1])**2+(points[0][2]-points[1][2])**2)
      dist=dist+long
  return dist


def Couche(profondeur):
  hor=-floor(profondeur/epaissHor)
  if hor>=NBHORMAX:
    hor=NBHORMAX-1
  if hor<0:
    hor=0
  
  return int(hor)

def DetermineAccroiss(Pourcentage,X,AccroissDemande):
  newbiomass=X.biomass+X.Besoinencroiss*Pourcentage
  if newbiomass>X.biomass:
    newtaille=X.Taillefeuille
    while BiomassFeuille(newtaille,X.coupe,X.geno)<newbiomass and newtaille<(X.Taillefeuille+AccroissDemande):
      newtaille+=0.1
    newtaille=newtaille-0.1
    while BiomassFeuille(newtaille,X.coupe,X.geno)<newbiomass and newtaille<(X.Taillefeuille+AccroissDemande):
      newtaille+=0.01
    #if BiomassFeuille(newtaille,X.coupe,X.geno)>=newbiomass:
    #  print('ici1','AccroissReduit')
    #else:
    #  print('ici2','AccroissComplet')
    return newtaille-0.005-X.Taillefeuille
  else:
    return 0

def BiomassFeuille(long,coupe,geno):
  coupe=0
  if geno<2:
    if long==0:
      MS=0
    else:
      #MS=(0.0016546297*exp(0.0000110784*(long+coupe)**2+0.0098368337*(long+coupe))-0.0016546297)*(long/(long+coupe))
      MS=1.34*(0.0016546297*exp(0.0000110784*(long+coupe)**2+0.0098368337*(long+coupe))-0.0016546297)*(long/(long+coupe))
      #MS=1.674*(0.0016546297*exp(0.0000110784*(long)**2+0.0098368337*(long))-0.0016546297)
  else:
    if long==0:
      MS=0
    else:
      #MS=(0.0016546297*exp(0.0000110784*(long+coupe)**2+0.0098368337*(long+coupe))-0.0016546297)*(long/(long+coupe))
      MS=1.989*(0.0016546297*exp(0.0000110784*(long+coupe)**2+0.0098368337*(long+coupe))-0.0016546297)*(long/(long+coupe))
      #MS=1.278*1.554*(0.0016546297*exp(0.0000110784*(long)**2+0.0098368337*(long))-0.0016546297)
  return MS


def Start():
  global timing,growth_realized,surface_biomass,chemin_fichier,chemin_fichier2,chemin_fichier3,chemin_fichier4,chemin_fichier5,PourcentageRootGrowthRealized,long_root,RB,simul_expe,TPS_expe,serie_foliaire,evol
  #PourcentageRootGrowthRealized=0
  timing = t.time()
  growth_realized=1
  dt=1
  
  
  chemin_fichier=open(OUTPUTS_DIRPATH + "/surface_biomass.csv","wb")
  surface_biomass=csv.writer(chemin_fichier)
  #surface_biomass.writerow(["TPS","surface foliaire"])
  surface_biomass.writerow(["TPS","id plante","id talle","ordre","nb_feuillemergees"])
  
  chemin_fichier2=open(OUTPUTS_DIRPATH + "/sortie simul.csv","wb")
  long_root=csv.writer(chemin_fichier2)
  #long_root.writerow(["TPS","shoot biomass","nb_feuille_emerge","nb_talles","nb_root","root biomass","newSB-SB","BiomassCree","RootBiomassCree"])
  long_root.writerow(["TPS","surfoliaire","nb_feuille_emerge","nb_feuille_totale","nb_talles_emerge","biomShoot","biomRoot","surfoliaire","nb_feuille_emerge","nb_feuille_totale","nb_talles_emerge","biomShoot","biomRoot"])
  chemin_fichier3=open(OUTPUTS_DIRPATH + "/sortie simul ValidCoupe.csv","wb")
  simul_expe=csv.writer(chemin_fichier3)
  simul_expe.writerow(["TPS","C","nb_feuille","nb_talle","nb_root_visible","nb_root","MS_feuille","MS_root","Surface foliaire","long_root","profondeur","LongTotalRoot"])
  TPS_expe=range(1000)#[100.0,200.0,300.0,501.0,400.0,500.0,600.0,700.0,800.0,900.0,1000.0,1100.0]#[505.0,558.0,642.0,718.0,774.0,783.0,792.0,830.0, 850.0, 917.0,974.0]
  
  #RB=0
  
  chemin_fichier4=open(OUTPUTS_DIRPATH + "/sortie serie foliaire.csv","wb")
  serie_foliaire=csv.writer(chemin_fichier4)
  serie_foliaire.writerow(["TPS","talle","rang","longueur","gaine","limbe","phase"])
  
  chemin_fichier5=open(OUTPUTS_DIRPATH + "/evol.csv","wb")
  evol=csv.writer(chemin_fichier5)
  #surface_biomass.writerow(["TPS","surface foliaire"])
  evol.writerow(["temps","Surf Foliaire","Ray","BiomProd","ShootBiom","RootBiom"])
  
  




def StartEach():
  global DCOUP,nb_racines,RootPotentialNewBiomass,longueur_totale_feuille,Rootbiom,num_pointe,groupe,dt,nb_racines_visible,reprise_coupe
  
  RootPotentialNewBiomass=[0]*(NBlignes*NBcolonnes)
  longueur_totale_feuille=0
  Rootbiom=0
  if TPS==DCOUP:
    if groupe==1:
      groupe=2
      dt=0.25
  
  if (TPS==DCOUP+1):
    if groupe==2:
      if DCOUP+FREQUCOUPE < PREMIERCOUPE+DUREECOUPE:
        DCOUP=DCOUP+FREQUCOUPE
        print('prochaine_coupe',DCOUP)
      reprise_coupe=True
      groupe=1
      dt=1
      
  if TPS==DCOUP+0.75:
    for i in range(len(Seuil)):
      for j in range(len(Seuil[i])):
        Seuil[i][j]=5.5
  print "groupe",groupe







def EndEach(lstring,lscene):
  global TPS,mtg,Surfoliairetotale,dt,les_pointes,les_primordiums,RootPotentialNewBiomass,longueur_totale_feuille,PourcentageRootGrowthRealized,les_feuilles,Rootbiom,Reserve,num_pointe,SB,Surfoliaireencours,RB,SBap_recolte,simul_expe,TPS_expe,groupe,dt,groupe,NBlignes,NBcolonnes,PourcentageFeuilGrowthRealized,Demande_feuille,C,reprise_coupe,evol,Ray,BiomProd
  
  TPS=TPS+dt  
  mtg=my_axialtree2mtg(lstring, scales,None, parameters,TREE)
  Activate(mtg)
  print('phrase initial',len(lstring))
  
  #energy, emission, direction, elevation , azimuth  = turtle.turtle()
  #ligthsources = zip(energy,direction)
  #ligthsources = [(1, (-0.0, 0.0, -1.0))]
  ligthsources=r'E:/Projets/ESIP/2016-2017/Plant_Model\zenith.light'
  
  
  
  if TPS>6000:#  TPS == 300:#  and TPS % 20 == 0:# and TPS in range(801):
    timing_method1 = t.time()
    scene=Scene(lscene)
    Ray=[0.]*(NBlignes*NBcolonnes)
    BiomProd=[0.]*(NBlignes*NBcolonnes)
    for i in range(len(scene)-1,-1,-1):
      if lstring[scene[i].getId()].name <> 'Feuille':
        scene.remove(scene[i])
    scene.save('E:/Projets/ESIP/2016-2017/Plant_Model/ma_scene.geom')
    
    res = apply_caribu(lstring, scene, ligthsources)
    
    for i in res:
      Ray[lstring[i][0].id_plante]+=res[i]
    
    for i in range(NBlignes*NBcolonnes):
      Ray[i]=Ray[i]/Surfoliairetotale[i]
      BiomProd[i]=Ray[i]*(25*0.48)*2
    
    print('somme',Ray[0])
    print('temps d exec de caribu:',t.time()-timing_method1)
    
    #evol.writerow([TPS,Surfoliairetotale[0],Ray[0],BiomProd[0],SB[0]])
  
  
  
  
  if reprise_coupe==True:
    reprise_coupe=False
  
  
  
  #if groupe==1:
  
  SB=[0.]*(NBlignes*NBcolonnes)
  #PourcentageFeuilGrowthRealized=[1]*(NBlignes*NBcolonnes)
  les_pointes=[[mtg.property('pte').get(x).id_pointe,x] for x in VtxList(5) if Class(x)=='t']
  #les_primordiums=[x for x in VtxList(5) if Class(x)=='S']
  #les_feuilles=[x for x in VtxList(4) if Class(x)=='F']
  #les_racines=[x for x in VtxList(4) if Class(x)=='r']
  limbe=[0,0]
  limbe2=[0,0]
  gaine=[0,0]
  gaine2=[0,0]
  Long=[0,0]
  long2=[0,0]
  long3=[0,0]
  for ID in xrange(NBlignes*NBcolonnes):
    newSB=0
    #if TPS==PREMIERCOUPE:
    #  newSB=SB-0.221  #TF   0.1591  #TG
    #  SBap_recolte=newSB
    #else:
    Pl=[p for p in VtxList(2) if mtg.property('ParamPlante').get(p).id_plante==ID]
    if Pl ==[]:
      geno=0
    else:
      Pl=Pl[0]
      geno=mtg.property('ParamPlante').get(Pl).id_geno
    
    les_feuilles=[x for x in VtxList(4) if Class(x)=='F' and mtg.property('ParamFeuille').get(x).id_plante==ID]
    
    Demande_feuille_dans_gaine[ID]=sum([mtg.property('ParamFeuille').get(x).Besoinencroiss for x in les_feuilles if mtg.property('ParamFeuille').get(x).Phase==0])
    Demande_feuille_hors_gaine[ID]=sum([mtg.property('ParamFeuille').get(x).Besoinencroiss for x in les_feuilles if mtg.property('ParamFeuille').get(x).Phase>0])
    
    Demande_feuille[ID]=sum([Demande_feuille_dans_gaine[ID],Demande_feuille_hors_gaine[ID]])
    SB[ID]=sum([mtg.property('ParamFeuille').get(x).biomass for x in les_feuilles])
    
    Surfoliairetotale[ID]=sum([mtg.property('ParamFeuille').get(x).surface for x in les_feuilles])
    
    
    
    BiomassCree=0
    if SB[ID]>0 and t1[geno]*exp(TPS*t2[geno])-t1[geno]>0:
      BiomassCree=t2[geno]*(SB[ID]+t1[geno])*(1+Beta[geno]*Alpha[geno]*(SB[ID])**(Alpha[geno]-1))
       #print('biomasses',BiomassCree,SB[ID], Next_biom_feuil[ID],Next_biom_feuil[ID]-SB[ID])
      if BiomassCree>0 and 0.99*BiomassCree-(Demande_feuille[ID])>0:#Next_biom_feuil[ID]-SB[ID]>0 and 
        RootBiomassCree=BiomassCree-(Demande_feuille[ID])
        RB[ID]+=RootBiomassCree
        PourcentageFeuilGrowthRealized[ID]=1
      else:
        RootBiomassCree=0.01*BiomassCree
        RB[ID]+=RootBiomassCree
        BiomassFeuilCree=0.99*BiomassCree
        PourcentageFeuilGrowthRealized[ID]=BiomassFeuilCree/Demande_feuille[ID]
        if PourcentageFeuilGrowthRealized[ID]<0:
          #print("r0000000r000000")
          PourcentageFeuilGrowthRealized[ID]=0
    else:
      RootBiomassCree=0
    
    
    #if TPS>40:
    #  BiomassCree=Ray[ID]*0.00018#*(1+Beta[geno]*Alpha[geno]*(SB[ID])**(Alpha[geno]-1))
    #  
    #  if BiomassCree>0 and BiomassCree-(Demande_feuille[ID])>0:
    #    RootBiomassCree=BiomassCree-(Demande_feuille[ID])
    #    RB[ID]+=RootBiomassCree
    #    BiomassFeuilCree=Demande_feuille[ID]
    #    PourcentageFeuilGrowthRealized[ID]=1
    #  else:# Demande_feuille[ID]>0:
    #    RootBiomassCree=0
    #    RB[ID]+=RootBiomassCree
    #    BiomassFeuilCree=BiomassCree
    #    PourcentageFeuilGrowthRealized[ID]=BiomassFeuilCree/Demande_feuille[ID]
    #else:
    #  BiomassCree=0   
    #  RootBiomassCree=0
    #  BiomassFeuilCree=0
    
    
    #if Ray[ID]<=0 or TPS<40:
    PourcentageFeuilGrowthRealized[ID]=1
    
    
    
    
    
    
    if RootPotentialNewBiomass[ID]==0:
      PourcentageRootGrowthRealized[ID]=0
      #Reserve[ID]=Reserve[ID]+RootBiomassCree
    else:
      PourcentageRootGrowthRealized[ID]=RootBiomassCree/RootPotentialNewBiomass[ID]
      if PourcentageRootGrowthRealized[ID]>1:
        PourcentageRootGrowthRealized[ID]=1
        #Reserve[ID]=Reserve[ID]+(RootBiomassCree-RootPotentialNewBiomass[ID])
      else:
        if RootPotentialNewBiomass[ID]-RootBiomassCree < Reserve[ID]:
          PourcentageRootGrowthRealized[ID]=1
          #Reserve[ID]=Reserve[ID]-(RootPotentialNewBiomass[ID]-RootBiomassCree)
        else:
          PourcentageRootGrowthRealized[ID]=(RootBiomassCree+Reserve[ID])/RootPotentialNewBiomass[ID]
          #Reserve[ID]=0
    
    
    #PourcentageFeuilGrowthRealized[ID]=1 #le temps de tester
    print('PourcentageFeuilGrowthRealized',PourcentageFeuilGrowthRealized,PourcentageRootGrowthRealized)
    print('detail',Demande_feuille[0],RootPotentialNewBiomass[0],BiomassCree,RootBiomassCree)
    
    #if TPS<=PREMIERCOUPE:
    #  PourcentageRootGrowthRealized[ID]=1
    
    #SB[ID]=newSB
    
    
    
    #RB=0
    #for x in VtxList(5):
    #  if Class(x)=='s':
    #    RB=RB+(mtg.property('seg').get(x).longueur*P_RootMasseVolumique*pi*(mtg.property('seg').get(x).diametre/2)**2)
    #  elif Class(x)=='t':
    #    RB=RB+(mtg.property('pte').get(x).longueur*P_RootMasseVolumique*pi/3*(mtg.property('pte').get(x).diametre/2)**2)
  
  #les_feuille_emerge=[x for x in VtxList(4) if (Class(x)=='F' and mtg.property('ParamFeuille').get(x).Phase>=1)]
  #les_phytos=[Complex(x) for x in les_feuille_emerge if Rank(Complex(x))==0]
  
  #if TPS<PREMIERCOUPE:
  #  PourcentageFeuilGrowthRealized=[1]*(NBlignes*NBcolonnes)
  #longtotal=0
  #print('pourcentage',PourcentageRootGrowthRealized,PourcentageFeuilGrowthRealized)
  #for x in les_racines:
  #  ensemble_de_racine=Components(x)
  #  #print(ensemble_de_racine)
  #  axe=Path(ensemble_de_racine[0],ensemble_de_racine[len(ensemble_de_racine)-1])
  #  axe.append(ensemble_de_racine[0])
  #  for y in axe:
  #    if Class(y)=='s':
  #      longtotal=longtotal+mtg.property('seg').get(y).longueur
  #    elif Class(y)=='t':
  #      longtotal=longtotal+mtg.property('pte').get(y).longueur
  #  derniere_pointe=ensemble_de_racine[len(ensemble_de_racine)-1]
  #  #long_root.writerow([TPS,SB,RB,len(les_feuille_emerge),len(les_racines),longtotal,PourcentageRootGrowthRealized])
  #  
  #  
  
  
  
  
  
  #long_root.writerow([TPS,newSB,len(les_feuille_emerge),len(les_phytos),len(les_racines),RB,newSB-SB,BiomassCree,RootBiomassCree])
  #SB=newSB
  #Surfoliairetotale=Surfoliaireencours
  Surfoliaireencours=[0.]*(NBlignes*NBcolonnes)
  
  #surface_biomass.writerow([TPS,Surfoliairetotale])
  
  
  
  #if sum([f[0] for f in les_longs2])<sum([f[0] for f in les_longs]):
  #  long_root.writerow([])
  #  long_root.writerow([])
  #  for j in xrange(len(les_longs)):
  #    if les_longs[j][0]>les_longs2[j][0]:
  #      long_root.writerow(["longueurs avant","longueur apres"])
  #      long_root.writerow([les_longs[j][0],les_longs2[j][0]])
  #      root=les_longs2[j][1]
  #      comp=Complex(root)
  #      
  #      for x in VtxList(3):
  #        print([Label(v) for v in Components(x)])
  #      
  #      #feuill=[v for v in Components(comp) if Class(v)=='F'][0]
  #      long_root.writerow([])
  #      #long_root.writerow([Order(comp),mtg.property('ParamFeuille').get(feuill).id_talle,mtg.property('ParamFeuille').get(feuill).id_rang])
  #  
  #  long_root.writerow([])
  #  long_root.writerow([])
  
  les_feuilles=[x for x in VtxList(4) if Class(x)=='F']
  les_feuilles_emergees=[x for x in VtxList(4) if Class(x)=='F' and mtg.property('ParamFeuille').get(x).Phase>0]
  les_racines=[x for x in VtxList(4) if Class(x)=='r']
  les_pointes2=[x for x in VtxList(5) if Class(x)=='t']
  print(len(les_pointes2))
  
  #les_longs=les_longs2
  if TPS in TPS_expe:
    nb_feuilles=[0,0,0]
    nb_racines=[0,0,0]
    nb_racines_visible=[0,0,0]
    longroottotal=[0,0,0]
    longueurtotale=[0,0,0]
    profond=[0,0,0]
    for x in les_feuilles_emergees:
      nb_feuilles[mtg.property('ParamFeuille').get(x).id_plante]+=1
    nb_talles_emergees=[0,0,0]
    for x in les_feuilles_emergees:
      if mtg.property('ParamFeuille').get(x).id_rang==1:
        nb_talles_emergees[mtg.property('ParamFeuille').get(x).id_plante]+=1
        ordre=Order(Complex(x)) 
        les_feuilles_dans_talle=[y for y in les_feuilles_emergees if mtg.property('ParamFeuille').get(y).id_plante==mtg.property('ParamFeuille').get(x).id_plante and mtg.property('ParamFeuille').get(y).id_talle==mtg.property('ParamFeuille').get(x).id_talle]
        surface_biomass.writerow([TPS,mtg.property('ParamFeuille').get(x).id_plante,mtg.property('ParamFeuille').get(x).id_talle,ordre,len(les_feuilles_dans_talle)])
    
    for x in les_racines:
      long=0
      ensemble_de_racine=Components(x)
      ID=mtg.property('ParamRacine').get(x).id_plante
      for y in ensemble_de_racine:
        if Class(y)=='s':
          longueurtotale[ID]+=mtg.property('seg').get(y).longueur
        elif Class(y)=='t':
          longueurtotale[ID]+=mtg.property('pte').get(y).longueur
      axe=Path(ensemble_de_racine[0],ensemble_de_racine[len(ensemble_de_racine)-1])
      axe.append(ensemble_de_racine[0])
      
      
      for y in axe:
        if Class(y)=='s':
          long=long+mtg.property('seg').get(y).longueur
        elif Class(y)=='t':
          long=long+mtg.property('pte').get(y).longueur
      longroottotal[mtg.property('ParamRacine').get(x).id_plante]+=long
      nb_racines_visible[mtg.property('ParamRacine').get(x).id_plante]+=1
      if long>5:
        nb_racines[mtg.property('ParamRacine').get(x).id_plante]+=1
      pointe=axe[len(axe)-2]
      profond[mtg.property('ParamRacine').get(x).id_plante]=max(profond[mtg.property('ParamRacine').get(x).id_plante],mtg.property('pte').get(pointe).profondeur)
      surface_biomass.writerow([TPS,mtg.property('ParamRacine').get(x).id_plante,mtg.property('pte').get(pointe).diametre,long,mtg.property('pte').get(pointe).arretee])
      
      
    #  print('talles',nb_talle,nb_talles_emergees)
    for i in range(NBlignes*NBcolonnes):
      simul_expe.writerow([TPS,C[i],nb_feuilles[i],nb_talles_emergees[i],nb_racines[i],nb_racines_visible[i],SB[i],RB[i],Surfoliairetotale[i],longroottotal[i],profond[i],longueurtotale[i]])#,'TG',nb_feuilles[1],nb_talles_emergees[1],nb_racines[1],SB[1],RB[1],Surfoliairetotale[1],longroottotal[1]])
  #  longueurs=[[],[]]
  #  
  #  #longtotal=0
  #  #nomb_racines=0
  #  #for x in les_racines:
  #  #  long=0
  #  #  ensemble_de_racine=Components(x)
  #  #  #print(ensemble_de_racine)
  #  #  axe=Path(ensemble_de_racine[0],ensemble_de_racine[len(ensemble_de_racine)-1])
  #  #  axe.append(ensemble_de_racine[0])
  #  #  for y in axe:
  #  #    if Class(y)=='s':
  #  #      long=long+mtg.property('seg').get(y).longueur
  #  #    elif Class(y)=='t':
  #  #      long=long+mtg.property('pte').get(y).longueur
  #  #  longtotal=longtotal+long
  #  #  if long>5:
  #  #    nomb_racines=nomb_racines+1
  #  #  
  #  #  
  #  
  #  
  #  #simul_expe.writerow(["TF","R2",TPS,nomb_racines,len(les_feuille_emerge),len(les_phytos),longtotal,SB,RB,Surfoliairetotale])
  
  
  
  #for x in les_racines:
  #  ensemble_de_racine=Components(x)
  #  axe=Path(ensemble_de_racine[0],ensemble_de_racine[len(ensemble_de_racine)-1])
  #  axe.append(ensemble_de_racine[0])
  #  nb_tip=[x for x in axe if Class(x)=='t']
  #  #print('pointe dans axe',nb_tip)
  #  if len(nb_tip)>1:
  #    print('probleme !!!!!!!!!!!!!!!!!!!!!!!')
  #  long=0
  #  for y in axe:
  #    if Class(y)=='s':
  #      long=long+mtg.property('seg').get(y).longueur
  #    elif Class(y)=='t':
  #      long=long+mtg.property('pte').get(y).longueur
  #  pointe=axe[len(axe)-2]
  #  #surface_biomass.writerow([TPS,mtg.property('ParamRacine').get(x).id_plante,mtg.property('pte').get(pointe).diametre,long])
  #  if mtg.property('pte').get(pointe).diametre<0.52:
  #    print 'probleme racine'
  #    print axe
  #    print ensemble_de_racine
  
  
  
  les_feuilles_emergees=[]
  les_feuilles_emergees.append(len([x for x in VtxList(4) if Class(x)=='F' and mtg.property('ParamFeuille').get(x).Phase>0 and mtg.property('ParamFeuille').get(x).id_plante==0]))
  les_feuilles_emergees.append(len([x for x in VtxList(4) if Class(x)=='F' and mtg.property('ParamFeuille').get(x).Phase>0 and mtg.property('ParamFeuille').get(x).id_plante==1]))
  talles=[]
  
  les_feuilles2=[]
  les_feuilles2.append(len([x for x in VtxList(4) if Class(x)=='F' and mtg.property('ParamFeuille').get(x).id_plante==0]))
  les_feuilles2.append(len([x for x in VtxList(4) if Class(x)=='F' and mtg.property('ParamFeuille').get(x).id_plante==1]))
  
  
  talles.append(len([x for x in VtxList(4) if Class(x)=='F' and mtg.property('ParamFeuille').get(x).Phase>0 and mtg.property('ParamFeuille').get(x).id_rang==1 and mtg.property('ParamFeuille').get(x).id_plante==0]))
  talles.append(len([x for x in VtxList(4) if Class(x)=='F' and mtg.property('ParamFeuille').get(x).Phase>0 and mtg.property('ParamFeuille').get(x).id_rang==1 and mtg.property('ParamFeuille').get(x).id_plante==1]))
  
  #long_root.writerow([TPS,SB[0],SB[1],RB[0],RB[1]])
  
  #if TPS in TPS_expe:
  #  long_root.writerow([TPS,Surfoliairetotale[0],les_feuilles_emergees[0],les_feuilles2[0],talles[0],SB[0],RB[0],Surfoliairetotale[1],les_feuilles_emergees[1],les_feuilles2[1],talles[1],SB[1],RB[1]])
  
  #for x in [x for x in VtxList(2) if Class(x)=='P']:
  #print('ici man')
  #tab=[]
  #display_mtg(mtg, x,tab)
  #filename = 'E:/Projets/ESIP/2016-2017/Plant_Model/essai display.mtg'
  #plantes=[x for x in VtxList(2) if Class(x)=='P']
  
  
  #  if les_racines<>[]:
  #    plante1=mtg.sub_mtg(les_racines[0])
  #    print('root',les_racines[0])
  #    f = open(filename, 'w')
  #    #properties = [(p, 'REAL') for p in plante1.property_names() if p not in ['edge_type', 'index', 'label']]
  #    mtg_lines = write_mtg(plante1)#,properties)
  #    f.write(mtg_lines)
  #    f.close()
  Demande_feuille=[0]*(NBlignes*NBcolonnes)
  #Next_biom_feuil=[0]*(NBlignes*NBcolonnes)
  #print(PourcentageFeuilGrowthRealized)
  #if TPS>5:
  #  print('talllage',nb_talle[0],nb_talle[1])
  
  #for i in range(NBlignes*NBcolonnes):
  #  nb_feuilles_emergees[i]=les_feuilles_emergees[i]
  #  simul_expe.writerow([TPS,C[i],nb_feuilles_emergees[i],nb_talles_emergees[i],nb_racines[i],SB[i],RB[i],Surfoliairetotale[i]])
  
  if TPS in range(801):
    evol.writerow([TPS,Surfoliairetotale[0],Ray[0],BiomProd[0],SB[0],RB[0]])
    #evol.writerow([TPS,Surfoliairetotale[0],Ray[0],SB[0],RB[0]])
  print("surface foliaire",Surfoliairetotale[0],SB[0])
  #print('seuil',Seuil)
  print('phrase final',len(lstring))
  print('TPS',TPS)



def End():
  global timing,chemin_fichier,TPS,mtg,long_root,chemin_fichier2,num_pointe,groupe,chemin_fichier5
  chemin_fichier.close()
  les_feuilles=[x for x in VtxList(4) if Class(x)=='F']
  les_feuille_emerge=[x for x in VtxList(4) if (Class(x)=='F' and mtg.property('ParamFeuille').get(x).Phase>=1)]
  les_racines=[x for x in VtxList(4) if Class(x)=='r']
  long_root.writerow(["TPS","nb_feuilles","nb_feuille_emergees","nb_racines"])
  long_root.writerow([TPS,len(les_feuilles),len(les_feuille_emerge),len(les_racines)])
  long_root.writerow([])
  long_root.writerow(["longueur_racine","longueur_axe"])
  
  for x in les_racines:
    diam=0
    ensemble_de_racine=Components(x)
    #print(ensemble_de_racine)
    axe=Path(ensemble_de_racine[0],ensemble_de_racine[len(ensemble_de_racine)-1])
    axe.append(ensemble_de_racine[0])
    longueur_axe=0
    for y in axe:
      if Class(y)=='s':
        longueur_axe=longueur_axe+mtg.property('seg').get(y).longueur
      elif Class(y)=='t':
        longueur_axe=longueur_axe+mtg.property('pte').get(y).longueur
        la_pointe=y
    
    longueur_root=0
    for y in ensemble_de_racine:
      if Class(y)=='s':
        longueur_root=longueur_root+mtg.property('seg').get(y).longueur
      elif Class(y)=='t':
        longueur_root=longueur_root+mtg.property('pte').get(y).longueur
        diam=mtg.property('pte').get(y).diametre
    arret=mtg.property('pte').get(la_pointe).arretee
    la_plante=mtg.property('ParamRacine').get(x).id_plante
    long_root.writerow([la_plante,longueur_root,longueur_axe,diam,arret])
  
  #long_root.writerow([])
  #long_root.writerow([])
  #long_root.writerow(["plante","talle","rang","phase"])
  #for x in les_feuilles:
  #  long_root.writerow([mtg.property('ParamFeuille').get(x).id_plante,mtg.property('ParamFeuille').get(x).id_talle,mtg.property('ParamFeuille').get(x).id_rang,mtg.property('ParamFeuille').get(x).Phase])
  #print(lstring)
  #arret=0
  #  if mtg.property('pte').get(derniere_pointe).arretee:
  #    arret=1
  #  else:
  #    arret=0
  #  
  #  if mtg.property('pte').get(derniere_pointe).senile:
  #    long_root.writerow([longueur_root,longueur_axe,arret,1])
  #  else:
  #    long_root.writerow([longueur_root,longueur_axe,arret,0])
  
  #for x in VtxList(3):
  #  print([Label(v) for v in Components(x)])
  #les_feuille_finies=[x for x in VtxList(4) if (Class(x)=='F' and mtg.property('ParamFeuille').get(x).Phase>=2 and Order(Complex(x))==0)]
  #for x in les_feuille_finies:
  #  long_root.writerow([mtg.property('ParamFeuille').get(x).Taillefeuille,mtg.property('ParamFeuille').get(x).Taillegaine])
  
  chemin_fichier2.close()
  chemin_fichier3.close()
  chemin_fichier4.close()
  chemin_fichier5.close()
  print 'Execution time :',t.time()-timing


def FoncCroiss(t, Ymax, te, tm): # fonction de croissance de feuille
  tend = te
  tmax=tm
  if (t>tend):
    y=Ymax
  else:
    y=Ymax*(1+((tend-t)/(tend-tmax)))*(pow((t/tend),(tend/(tend-tmax))))
  return y

def TpourY(Y, Ym, Te, Tm):  # retrouver le temps T auquel la taille de la feuille valait Y
  L=0
  i=0
  if Y>Ym:
    return Te
  else:
    while L<Y:
      L=FoncCroiss(i, Ym, Te, Tm)
      i=i+1
    j=max(i-1,0)
    L=FoncCroiss(j, Ym, Te, Tm)
    while L<=Y:
      L=FoncCroiss(j, Ym, Te, Tm)
      #print('j',j,'L',L)
      j=j+0.1
    k=max(j-1,0)
    L=FoncCroiss(k, Ym, Te, Tm)
    while L<=Y:
      L=FoncCroiss(k, Ym, Te, Tm)
      #print('k',k,'L',L)
      k=k+0.01
    l=max(k-1,0)
    L=FoncCroiss(l, Ym, Te, Tm)
    while L<=Y:
      L=FoncCroiss(l, Ym, Te, Tm)
      #print('k',k,'L',L)
      l=l+0.001
    return max(l-0.001,0)

def TpourY2(Y, Ym, Te, Tm):  # retrouver le temps T auquel la taille de la feuille valait Y
  curs1=0
  curs2=Te
  newt=Te/2
  #print 'new',newt
  while curs2-curs1>0.001:
    newt=curs1+(curs2-curs1)/2
    L=FoncCroiss(newt, Ym, Te, Tm)
    if L==Y:
      return newt
    elif L<Y:
      curs1=newt
    else:
      curs2=newt
  return curs1+(curs2-curs1)/2


#def TpourY3(Y, Ym, Te, Tm,curs1,curs2):
#    newt=curs1+(curs2-curs1)/2
#    #print 'new',newt
#    if curs2-curs1<=0.001:
#        return newt
#    else:
#        L=FoncCroiss(newt, Ym, Te, Tm)
#        if L==Y:
#            return newt
#        elif L<Y:
#            return TpourY3(Y, Ym, Te, Tm,newt,curs2)
#        else:
#            return TpourY3(Y, Ym, Te, Tm,curs1,newt)

Axiom: CouvertVegetal(0)

derivation length: 200


production:

#GetPos(a,b,c) < SegFeuille(X) :
#  X.hauteur=c
#  produce SegFeuille(X)

#GetPos(a,b,c) < tip(X) :
#  X.profondeur=-c
#  #print(X.profondeur)
#  produce tip(X)

CouvertVegetal(X):
  global groupe,NBlignes,NBcolonnes,genotype
  if groupe==1:
    if X==1:
      nproduce CouvertVegetal(2)
      for i in xrange(NBlignes):
        for j in xrange(NBcolonnes):
          id_plante=i*NBcolonnes+j
          geno=i
          genotype.append(geno)
          #print(geno)
          param=ParamPlante(id_plante,geno)
          nb_talle.append(0)
          #print(nb_talle)
          nproduce IN SB() RollR(45) MoveTo(j*120.,120.*i,0) Plante(param) IN EB()
    else:
      produce CouvertVegetal(X+1)
  else:
    produce CouvertVegetal(X)

Plante(X):
  global TPS,groupe
  if groupe==1:
    if TPS ==2:
      Seuil.append([5.5])
      Tailfingain.append([[5.5,5.5]])
      Y1=ParamPhytomere(id_plante=X.id_plante)
      YF=ParamFeuille(0,0,0,id_plante=X.id_plante,id_rang=1,Ymax=Premiecroiss[X.id_plante],Taillefinalel = 0.8*Premiecroiss[X.id_plante],Taillefinaleg = 0.2*Premiecroiss[X.id_plante])
      Yb=ParambourgeonRoot(X.id_plante,0,1)
      YAT=ParamApexTal(X.id_plante,0,1)
      YA=ParamApex(X.id_plante,0,1)
      produce Plante(X) phytomere(Y1) RollR(95) Entrenoeud bourgeonRoot(Yb) FLW SB Feuille(YF) FLW EB ApexTal(YAT) apex(YA)
  else:
    produce Plante(X)

phytomere(X):
  global groupe
  if groupe==1:
    X.age=X.age+1
    if (X.id_talle!=0 and X.id_rang==0):
      if (X.age>=120 and X.angletal<=divergetalle):
        X.angletal=X.angletal+(1./3.)
  else:
    produce phytomere(X)

Feuille(X):
  global mtg,NewShootBiomass,longueur_totale_feuille,les_feuilles,Surfoliaireencours,groupe,C,serie_foliaire
  X.surface=0
  #if X.id_talle==0:
  #  serie_foliaire.writerow([TPS,X.id_talle,X.id_rang,X.Taillefeuille,X.Taillegaine,X.Taillelimbe,X.Phase])
  if groupe==1:
    
    X.age=X.age+1  
    vtx_feuille=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang)][0]  # vertex de la feuille
    vtx_feuille_precedente=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang-1)]
    
    
    
    if(X.angleinsert<=INSERTIONLIMBE and X.Taillegaine>Tailfingain[X.id_plante][X.id_talle][X.id_rang-1] +1):
      X.angleinsert=X.angleinsert+1    
    
    Seuil[X.id_plante][X.id_talle]=max(Seuil[X.id_plante][X.id_talle],X.Taillegaine)
    if reprise_coupe==True:
      print('seuil',Seuil[X.id_plante][X.id_talle])
    Tailfingain[X.id_plante][X.id_talle][X.id_rang]=max(Tailfingain[X.id_plante][X.id_talle][X.id_rang],X.Taillegaine)
    
    plante=Complex(vtx_feuille,2)
    if X.Phase<2:    
      
      ##### Modif potentiel apres coupe ######
      
      if reprise_coupe==True and X.Phase==1:
        genotype=mtg.property('ParamPlante').get(plante).id_geno
        LEDGAINE=((0.2*110*5)*2)-110
        TrueAge=TpourY2(Seuil[X.id_plante][X.id_talle],110, 1.35*LEDGAINE,0.76*1.35*LEDGAINE)
        NewYmax=C[genotype]*((pow(2.718,(TrueAge+102)/31.5)-30)-(pow(2.718,(TrueAge+19.82)/20.99)))
        #print('Ymax',X.id_talle,X.id_rang,Seuil[X.id_plante][X.id_talle],NewYmax,X.Ymax,X.Taillefinaleg,X.Taillefinalel)
        if NewYmax>X.Ymax:
          NewYmax=X.Ymax
        elif NewYmax<X.Taillefeuille+X.coupe:
          X.Phase=2
        else:
          #LED1=((X.Taillefinaleg*5)*2)-X.Ymax
          NewTaillefinaleg=X.rapportK * NewYmax
          LED2=((NewTaillefinaleg*5)*2)-NewYmax
          X.Difftps=TpourY2(X.Taillefeuille+X.coupe,NewYmax,1.35*LED2,0.76*1.35*LED2)-X.age
          #TpourY2(Seuil[X.id_plante][X.id_talle], X.Ymax,1.35*LED,0.76*1.35*LED)-X.age#TpourY2(X.Taillefeuille+X.coupe,110, 1.35*LEDGAINE,0.76*1.35*LEDGAINE)
          X.Agecroiss=X.Difftps+X.age
          X.Ymax=NewYmax
        X.Taillefinalel=(1-X.rapportK)*X.Ymax
        X.Taillefinaleg=X.rapportK*X.Ymax
      
      
      
      ###### Gestion passage phase=0 a phase=1 ######
      if X.Phase==0:
        #if X.pseudotige>110:
        #  #print("limite croissance gaine")
        if X.Taillefeuille > Seuil[X.id_plante][X.id_talle]:
          X.Phase=1
          #print('Seuil de merde',Seuil[X.id_plante][X.id_talle])
          Seuil[X.id_plante][X.id_talle] *= 1.15
          LEDGAINE=((0.2*Premiecroiss[X.id_plante]*5)*2)-Premiecroiss[X.id_plante]
          X.TailleEmergence=Seuil[X.id_plante][X.id_talle]
          TrueAge=TpourY2(X.Taillefeuille+X.coupe,Premiecroiss[X.id_plante], 1.35*LEDGAINE,0.76*1.35*LEDGAINE)
          #print('ref',plante,mtg.property('ParamPlante').get(plante).id_plante)
          
          genotype=mtg.property('ParamPlante').get(plante).id_geno
          X.Ymax=C[genotype]*((pow(2.718,(TrueAge+102)/31.5)-30)-(pow(2.718,(TrueAge+19.82)/20.99))); #Alban
          #X.Ymax=C[genotype]*(1*exp(0.032*(TrueAge+102))-1*exp(0.047*(TrueAge+19.82))-30)  #TF
          
          #else:
          #  X.Ymax=0.7*(1*exp(0.0110422966*(TrueAge+772.67636741))-1*exp(0.0113550477*(TrueAge+743.16065674))-602.78369237) #C=0.7
          #  #X.Ymax=(1*exp(0.0250863392*(TrueAge+200.53615212))-1*exp(0.0280890692*(TrueAge+160.2264956))-129.08189529)  #TG
          #  #X.Ymax= 1*exp(0.0251*((X.age-1)+200.1))-1*exp(0.0281*((X.age-1)+158.9))-129.1  #TG
          #X.Ymax= ((pow(2.718,((X.age-1)+102)/31.5)-30)-(pow(2.718,((X.age-1)+19.82)/20.99)))   # FL
          #X.Ymax= 0.85*((pow(2.718,((X.age-1)+102)/31.5)-30)-(pow(2.718,((X.age-1)+19.82)/20.99)))   # New FC
          #X.Ymax=0.55*((615*pow(2.718,X.age*0.0053))-736.9-(0.1207*pow(2.718,X.age*0.062)))   # FC
          X.rapportK=0.1+((TrueAge-1)/600.)
          X.Taillefinalel=(1-X.rapportK)*X.Ymax
          X.Taillefinaleg=X.Ymax*X.rapportK
          
          LED=((X.Taillefinaleg*5)*2)-X.Ymax
          #LEDGAINE=((0.2*110*5)*2)-110
          X.Difftps=TpourY2(Seuil[X.id_plante][X.id_talle], X.Ymax,1.35*LED,0.76*1.35*LED)-X.age#TpourY2(X.Taillefeuille+X.coupe,110, 1.35*LEDGAINE,0.76*1.35*LEDGAINE)
          
          
          
          X.AgeCroiss=X.age+X.Difftps#TpourY(X.Taillefeuille, X.Ymax ,1.35*(((X.Ymax/0.2)*(0.2+((X.age/(60.*10.))-0.1))*2.)-X.Ymax),0.76*1.35*(((X.Ymax/0.2)*(0.2+((X.age/(60.*10.))-0.1))*2.)-X.Ymax))
          #print('Ymax-passage',X.id_talle,X.id_rang,TrueAge,Seuil[X.id_plante][X.id_talle],X.Taillefeuille,X.coupe,Premiecroiss[X.id_plante],X.Ymax,X.Taillefinaleg,X.AgeCroiss,X.Difftps)
          
      
      ###### croissance ######
      
      LEDGAINE=((X.Taillefinaleg*5)*2)-X.Ymax
      Accroiss=0
      #if (X.Taillegaine< Tailfingain[X.id_plante][X.id_talle][X.id_rang-1] +13):
      inversea=TpourY2(X.Taillefeuille+X.coupe, X.Ymax, 1.35*LEDGAINE,0.76*1.35*LEDGAINE)
      #print('temps',inversea,X.Agecroiss)
      if(X.Phase==0):
        inversea=TpourY2(X.Taillefeuille+X.coupe, X.Ymax, 1.35*LEDGAINE,0.76*1.35*LEDGAINE)
        #print(inversea+1,X.age)
        #print('Ymax1',X.id_talle,X.id_rang,Seuil[X.id_plante][X.id_talle],X.Taillefinaleg,inversea,X.Ymax,1.35*LEDGAINE,0.76*1.35*LEDGAINE)
        AccroissDemande=FoncCroiss(inversea+1, X.Ymax, 1.35*LEDGAINE, 0.76*1.35*LEDGAINE)-FoncCroiss(inversea, X.Ymax, 1.35*LEDGAINE, 0.76*1.35*LEDGAINE)
        #Accroiss=FoncCroiss(X.age, X.Ymax, 1.35*LEDGAINE, 0.76*1.35*LEDGAINE)-FoncCroiss(X.age-1, X.Ymax, 1.35*LEDGAINE, 0.76*1.35*LEDGAINE)
        X.Agecroiss=X.age
      if(X.Phase==1):
        #AccroissDemande=(FoncCroiss(inversea+1, X.Ymax, 1.35*LEDGAINE, 0.76*1.35*LEDGAINE)-FoncCroiss(inversea, X.Ymax, 1.35*LEDGAINE, 0.76*1.35*LEDGAINE))*PourcentageFeuilGrowthRealized[mtg.property('ParamPlante').get(plante).id_plante]       
        #print('Ymax2',X.id_talle,X.id_rang,Seuil[X.id_plante][X.id_talle],X.Taillefinaleg,X.Agecroiss,X.Ymax,1.35*LEDGAINE,0.76*1.35*LEDGAINE)
        AccroissDemande=(FoncCroiss(X.Agecroiss+1, X.Ymax, 1.35*LEDGAINE, 0.76*1.35*LEDGAINE)-FoncCroiss(X.Agecroiss, X.Ymax, 1.35*LEDGAINE, 0.76*1.35*LEDGAINE))
        X.Agecroiss=X.age+X.Difftps
      Pourcent=PourcentageFeuilGrowthRealized[mtg.property('ParamPlante').get(plante).id_plante]
      if X.Phase==2:
        AccroissDemande=0
      
      
      if Pourcent==1:
        Accroiss=AccroissDemande
      else:
        if AccroissDemande<=0.02:
          Accroiss=AccroissDemande
        else:
          Accroiss=DetermineAccroiss(Pourcent,X,AccroissDemande)
      
      #if TPS>PREMIERCOUPE:
      #  print(AccroissDemande,Accroiss)
      
      
      
      
      if (X.Taillegaine>0.98*X.Taillefinaleg and X.Taillegaine<=Tailfingain[X.id_plante][X.id_talle][X.id_rang-1] -5 and X.Phase==1):
        Accroiss = 1
      
      #if (X.Taillegaine>=Tailfingain[X.id_plante][X.id_talle][X.id_rang-1]  +13 and X.Phase==1):
      #  Accroiss=0
      #  print('ici2334324')
      
      
      #taillefictive=TpourY()
      limbefictif=0.973*FoncCroiss(X.Agecroiss-1, X.Ymax, 1.35*LEDGAINE, 0.76*1.35*LEDGAINE)
      if X.R==0.973:
        
        #print(limbefictif,X.Taillelimbe)
        if limbefictif>(0.75*X.Taillefinalel):
          X.R=0.965
      
      if X.R==0.965 and limbefictif>X.Taillefinalel:
        X.R = 0
      
      #R=0
      #if ((X.Taillelimbe+X.coupe)<(0.75*X.Taillefinalel)):
      #  R=0.973
      #if (((X.Taillelimbe+X.coupe)>(0.75*X.Taillefinalel)) and ((X.Taillelimbe+X.coupe)<X.Taillefinalel)):
      #  R=0.965
      
      
      if X.Cutstatus<2: #le limbe n'est pas entièrement coupé
        X.Taillefeuille=X.Taillefeuille+Accroiss
        X.Taillelimbe=X.Taillelimbe+Accroiss*X.R
        X.Taillegaine=X.Taillegaine+Accroiss*(1-X.R)
      else:
        X.Taillegaine=X.Taillegaine+Accroiss*(1-X.R)
        X.Taillefeuille=X.Taillefeuille+Accroiss*(1-X.R)
      
      if Accroiss==0:
        #print('arret',X.id_plante,'feuille',X.Ymax,X.Taillefeuille+X.coupe,'gaine',X.Taillefinaleg,X.Taillegaine,'limbe',X.Taillefinalel,X.Taillelimbe,'seuil',Seuil[X.id_plante][X.id_talle],Tailfingain[X.id_plante][X.id_talle][X.id_rang-1])
        X.Besoinencroiss=0
        X.Phase=2
      
      X.biomass=BiomassFeuille(X.Taillefeuille,X.coupe,X.geno)
      
      if X.Phase<2:
        if (X.Taillegaine< Tailfingain[X.id_plante][X.id_talle][X.id_rang-1] +13):
          inversea=TpourY2(X.Taillefeuille+X.coupe, X.Ymax, 1.35*LEDGAINE,0.76*1.35*LEDGAINE)
        if(X.Phase==0):
          NextAccroiss=FoncCroiss(X.age+1, X.Ymax, 1.35*LEDGAINE, 0.76*1.35*LEDGAINE)-FoncCroiss(X.age, X.Ymax, 1.35*LEDGAINE, 0.76*1.35*LEDGAINE)
          #X.Agecroiss=X.age
        if(X.Phase==1):
          NextAccroiss=(FoncCroiss(X.Agecroiss+1, X.Ymax, 1.35*LEDGAINE, 0.76*1.35*LEDGAINE)-FoncCroiss(X.Agecroiss, X.Ymax, 1.35*LEDGAINE, 0.76*1.35*LEDGAINE))         
          #X.Agecroiss=X.age+X.Difftps
        
        if mtg.property('ParamPlante').get(plante).id_geno==0:
          long=X.Taillefeuille+NextAccroiss
          Next_feuil=BiomassFeuille(long,X.coupe,X.geno)
          
        else:
          long=X.Taillefeuille+NextAccroiss
          Next_feuil=BiomassFeuille(long,X.coupe,X.geno)
        X.Besoinencroiss=Next_feuil-X.biomass
        #Next_biom_feuil[mtg.property('ParamPlante').get(plante).id_plante]=Next_biom_feuil[mtg.property('ParamPlante').get(plante).id_plante]+Next_feuil
      #NewShootBiomass=NewShootBiomass+Accroiss*0.0001
      ####### Senescence #######
      ##Agesenesc = 4000000.+(X.Ymax/20.)*30. 
      ##if (X.age>Agesenesc+100.):
      ##  produce Cut()            
      ##  #/* Pour que la feuille soit vraiment coupée supprimee de chaine, en ENTIER */
      ##else:
    else:
      
      if mtg.property('ParamPlante').get(plante).id_geno==0:
        long=X.Taillefeuille
        coupe=X.coupe
        Next_feuil=1.34*(0.0016546297*exp(0.0000110784*(long+coupe)**2+0.0098368337*(long+coupe))-0.0016546297)*(long/(long+coupe))
        #Next_feuil=1.674*(0.0016546297*exp(0.0000110784*(long)**2+0.0098368337*(long))-0.0016546297)*(long/(long+X.coupe))
      else:
        long=X.Taillefeuille
        coupe=X.coupe
        Next_feuil=1.34*(0.0016546297*exp(0.0000110784*(long+coupe)**2+0.0098368337*(long+coupe))-0.0016546297)*(long/(long+coupe))
        #Next_feuil=1.554*(0.0016546297*exp(0.0000110784*(long)**2+0.0098368337*(long))-0.0016546297)*(long/(long+X.coupe))
      #Next_biom_feuil[mtg.property('ParamPlante').get(plante).id_plante]=Next_biom_feuil[mtg.property('ParamPlante').get(plante).id_plante]+Next_feuil
    # La feuille est ecartee par une autre talle
    phytos_suivant=Sons(Complex(vtx_feuille))
    if phytos_suivant!=[]:
      phyto_suivant=phytos_suivant[len(phytos_suivant)-1]
      if len(Sons(phyto_suivant))>1:
        phyto_entrainant=Sons(phyto_suivant)[0]
        X.angletal=mtg.property('ParamPhytomere').get(phyto_entrainant).angletal
    longueur_totale_feuille=longueur_totale_feuille+X.Taillefeuille
    
    
    if (X.Phase>0):
      
      
      
      if X.Cutstatus<2:
        numsteps = ceil((X.Taillefeuille)/LSTEP)
      else:
        numsteps = ceil((X.Taillegaine)/LSTEP)
      
      numstepsg = ceil((X.Taillegaine)/LSTEP)
      
      for i in xrange(int(numsteps)):
        if (i>=numstepsg-1):
          taille = X.Taillelimbe+X.coupe
          L0 = X.Taillefinalel-taille
          if ((i-numstepsg)<((taille-Taillepointelineraire)/LSTEP)):
            large = (-1.38*pow(((L0+((i-numstepsg)*LSTEP))/X.Taillefinalel), 2)+0.66*((L0+((i-numstepsg)*LSTEP))/X.Taillefinalel)+0.903)*(((1.9645*log(X.Ymax))-5.701)/2)
          else:
            largini=(-1.38*pow(((L0+(((i-numstepsg)-1)*LSTEP))/X.Taillefinalel), 2)+0.66*((L0+(((i-numstepsg)-1)*LSTEP))/X.Taillefinalel)+0.903)*(((1.9645*log(X.Ymax))-5.701)/2)
            large=largini-(((i-numstepsg)-((taille-Taillepointelineraire)/LSTEP))*((largini*LSTEP)/Taillepointelineraire))
          
          if(i<numstepsg-1):
            large=0.
          
          Surfoliaireencours[X.id_plante]=Surfoliaireencours[X.id_plante]+large*2.*LSTEP  
          X.surface=X.surface+large*2.*LSTEP  
      
      largegaine=max((2/3.1415)*(1.9645*log(max(X.Taillegaine*5,1))-5.701),0.1)
      X.surface+=largegaine*pi*X.Taillegaine
      produce Feuille(X)
  
  
  
  elif groupe==2:
    
    if TPS==DCOUP:
      nproduce Feuille(X) IN SB
      
      if (X.Phase==0):
        numsteps=(X.Taillefeuille-X.coupe)/LSTEP
        for i in xrange(int(numsteps)):
          
          if(i<(10/LSTEP)):
            rank=X.id_rang
            global large
            PS=ParamSegFeuille(i,0)
            nproduce  Down(Torsiongaine*pow(-1,rank)) GetPos(0,0,0) SegFeuille(PS)
          
          if(i>(10/LSTEP)):
            #global large
            PS=ParamSegFeuille(i,0)
            nproduce GetPos(0,0,0) SegFeuille(PS)
      
      
      if (X.Phase>0):
        
        if X.Cutstatus<2:
          numsteps = ceil((X.Taillefeuille)/LSTEP)
        else:
          numsteps = ceil((X.Taillegaine)/LSTEP)
        
        numstepsg = ceil((X.Taillegaine)/LSTEP)
        
        for i in xrange(int(numsteps)):
          if (i<numstepsg-1):
            rank = X.id_rang
            
            if(i<(10/LSTEP)):
              if(i==1):
                PS=ParamSegFeuille(i,0)
                nproduce Down(Torsiongaine*pow(-1,rank))GetPos(0,0,0)SegFeuille(PS)
              else:
                PS=ParamSegFeuille(i,0)
                nproduce Down(Torsiongaine*pow(-1,rank))GetPos(0,0,0)SegFeuille(PS)
            else:
              PS=ParamSegFeuille(i,0)
              nproduce GetPos(0,0,0)SegFeuille(PS)
          
          else:
            
            if(i==numstepsg):
              
              if X.id_rang>4:
                pseudotige=max([Tailfingain[X.id_plante][X.id_talle][x] for x in range(X.id_rang-3,X.id_rang-1)])
              else:
                pseudotige=Tailfingain[X.id_plante][X.id_talle][X.id_rang-1]
              
              if ( X.Taillegaine > pseudotige):
                PS=ParamSegFeuille(i,0)
                nproduce Left(X.angleinsert)GetPos(0,0,0)SegFeuille(PS)
            
            if ((i>numsteps-2) and X.coupe>2):         # /* Pour avoir cicatrice au bout feuille coupées */
              if i<numstepsg:
                if X.Cutstatus==2:
                  PS=ParamSegFeuille(i,0)
                  nproduce GetPos(0,0,0)SegFeuille(PS)
                else:
                  PS=ParamSegFeuille(i,0)
                  nproduce RollR(0)Left(curve)GetPos(0,0,0)SegFeuille(PS)
                
              else:
                PS=ParamSegFeuille(i,0)
                nproduce RollR(0)Left(curve)GetPos(0,0,0)SegFeuille(PS)
            
            if(X.id_rang==1 and X.id_talle>0):
              if (i>(X.TailleEmergence-2)/LSTEP):
                PS=ParamSegFeuille(i,0)
                nproduce RollR(0)Left(curve)GetPos(0,0,0)SegFeuille(PS)
              
              
              if (i<(X.TailleEmergence-2)/LSTEP):
                rank = X.id_rang
                
                if(i<(10/LSTEP)):
                  PS=ParamSegFeuille(i,0)
                  nproduce  Down(Torsiongaine*pow(-1,rank))GetPos(0,0,0)SegFeuille(PS)
                  
                else:
                  PS=ParamSegFeuille(i,0)
                  nproduce GetPos(0,0,0)SegFeuille(PS)
                  
            else:
              
              if X.id_rang>4:
                pseudotige=max([Tailfingain[X.id_plante][X.id_talle][x] for x in range(X.id_rang-3,X.id_rang-1)])
              else:
                pseudotige=Tailfingain[X.id_plante][X.id_talle][X.id_rang-1]
              
              if ( i > pseudotige/LSTEP ):
                if i<numstepsg:
                  if X.Cutstatus==2:
                    PS=ParamSegFeuille(i,0)
                    nproduce GetPos(0,0,0)SegFeuille(PS)
                  else:
                    PS=ParamSegFeuille(i,0)
                    nproduce RollR(0)Left(curve)GetPos(0,0,0)SegFeuille(PS)
                  
                else:
                  PS=ParamSegFeuille(i,0)
                  nproduce RollR(0)Left(curve)GetPos(0,0,0)SegFeuille(PS)
                
              if (i<pseudotige/LSTEP):
                rank = X.id_rang
                
                if(i<(10/LSTEP)):
                  PS=ParamSegFeuille(i,0)
                  nproduce  Down(Torsiongaine*pow(-1,rank))GetPos(0,0,0)SegFeuille(PS)
                  
                else:
                  PS=ParamSegFeuille(i,0)
                  nproduce GetPos(0,0,0)SegFeuille(PS)
                  
            
            
      produce IN EB
      
      
    elif TPS==DCOUP+0.5:
      vtx_feuille=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang)][0]
      #print('comp',X.Taillefeuille,mtg.property('ParamFeuille').get(vtx_feuille).Taillefeuille,len(Components(vtx_feuille)))
      longcoupee=LongueurFeuilleCoupee(vtx_feuille)
      if longcoupee<>-1:
        #print(X.id_plante,X.id_talle,X.id_rang,BiomassFeuille(X.Taillefeuille,X.coupe,X.geno),X.Taillefeuille,X.coupe)
        X.coupe=X.Taillefeuille-longcoupee
        #print('ici',X.coupe,X.Taillefeuille,longcoupee)
        X.Taillefeuille=longcoupee
        if X.Taillefeuille<X.Taillegaine:
          X.Taillegaine=X.Taillefeuille
          X.Taillelimbe=0
          X.Cutstatus=2
        else:
          X.Taillelimbe=X.Taillefeuille-X.Taillegaine
          X.Cutstatus=1
        #print(X.id_plante,X.id_talle,X.id_rang,BiomassFeuille(X.Taillefeuille,X.coupe,X.geno),X.Taillefeuille,X.coupe)
      #print('gaine',X.Taillegaine,X.Taillelimbe,X.Taillefeuille)
      produce Feuille(X)
    
    elif TPS==DCOUP+0.75:
      if X.Taillegaine*1.15>Seuil[X.id_plante][X.id_talle]:
        Seuil[X.id_plante][X.id_talle]=X.Taillegaine
      Tailfingain[X.id_plante][X.id_talle][X.id_rang]=X.Taillegaine
      if X.id_rang==1 and X.id_talle>0:
        vtx_feuille=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang)][0]
        phyto=Complex(vtx_feuille)
        phyto_precedent=Father(phyto)
        feuille_ref=[x for x in Components(phyto_precedent) if Class(x)=='F'][0]
        Seuil[X.id_plante][X.id_talle]=max(Seuil[X.id_plante][X.id_talle],mtg.property('ParamFeuille').get(feuille_ref).Taillegaine)
      X.biomass=BiomassFeuille(X.Taillefeuille,X.coupe,X.geno)
  else:
    produce Feuille(X)


GetPos(a,b,c):
  global TPS
  if TPS==DCOUP+0.5:
    produce

GetPos(a,b,c):
  global TPS
  if TPS in TPS_expe:
    produce

SegFeuille(X):
  global TPS
  if TPS==DCOUP+0.75:
    produce


apex(X):
  global TPS,les_feuilles,groupe
  if groupe==1:
    vtx_feuille=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang)][0]
    #print('emission feuille',Seuil[X.id_plante][X.id_talle],mtg.property('ParamFeuille').get(vtx_feuille).Taillefeuille)
    if X.retard==2:
      #Seuil[X.id_plante][X.id_talle]=Seuil[X.id_plante][X.id_talle] * 1.15
      Tailfingain[X.id_plante][X.id_talle].append(5.5)
      YP=ParamPhytomere(X.id_plante,X.id_talle,X.id_rang+1)
      YF=ParamFeuille(0,0,0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang+1,Ymax=Premiecroiss[X.id_plante],Taillefinalel = 0.8*Premiecroiss[X.id_plante],Taillefinaleg = 0.2*Premiecroiss[X.id_plante])
      Yb=ParambourgeonRoot(X.id_plante,X.id_talle,X.id_rang+1)
      YAT=ParamApexTal(X.id_plante,X.id_talle,X.id_rang+1)
      YA=ParamApex(X.id_plante,X.id_talle,X.id_rang+1)
      produce RollR(180) phytomere(YP) Entrenoeud bourgeonRoot(Yb) FLW SB() Feuille(YF) FLW EB() ApexTal(YAT) apex(YA)
    
    elif X.retard==1:
      X.retard=2
      produce apex(X)
    
    elif abs(Seuil[X.id_plante][X.id_talle]-mtg.property('ParamFeuille').get(vtx_feuille).Taillefeuille)<2:
      X.retard=1
      produce apex(X)
  else:
    produce apex(X)


ApexTal(X):
  global TPS,les_feuilles,Surfoliairetotale,groupe,alea1,alea1_index,alea2,alea2_index
  if groupe==1:
    vtx_feuille_ref=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang+2)]
    #if vtx_feuille_suivante!=[]:  # la feuille du rang+2 existe donc la feuille du rang+1 emerge
    if vtx_feuille_ref!=[]:
      seuil=max(Tailfingain[X.id_plante][X.id_talle][X.id_rang-1],5.5)
      
      if X.id_rang==0 and X.id_talle==0:
        produce F(0)
      
      #if X.id_plante==0:
      #  STOPTALLAGE==110000
      #else:
      #  STOPTALLAGE==110000
      genotype=X.id_plante
      Sitefillingproba=alea1[alea1_index[genotype]]*STOPTALLAGE#random.random()*STOPTALLAGE
      alea1_index[genotype]+=1
      #print(Surfoliairetotale)
      #if X.id_plante==0:
      #  SENSETALLAGE==11000
      #else:
      #  SENSETALLAGE==11000
      if (Surfoliairetotale[X.id_plante]<Sitefillingproba):
        #print('tallage?')
        if (Surfoliairetotale[X.id_plante]<=SENSETALLAGE):
          #print('test1')
          nb_talle[X.id_plante]=nb_talle[X.id_plante]+1
          Seuil[X.id_plante].append(seuil)
          Tailfingain[X.id_plante].append([5.5,5.5])
          YP=ParamPhytomere(X.id_plante,nb_talle[X.id_plante],0)
          YF=ParamFeuille(0,0,0,id_plante=X.id_plante,id_talle=nb_talle[X.id_plante],id_rang=1,Ymax=Premiecroiss[X.id_plante],Taillefinalel = 0.8*Premiecroiss[X.id_plante],Taillefinaleg = 0.2*Premiecroiss[X.id_plante])
          Yb=ParambourgeonRoot(X.id_plante,nb_talle[X.id_plante],1)
          YAT=ParamApexTal(X.id_plante,nb_talle[X.id_plante],1)
          YA=ParamApex(X.id_plante,nb_talle[X.id_plante],1)
          produce SB phytomere(YP) RollR(95) GetHead(0, 0, 0) Entrenoeud bourgeonRoot(Yb) FLW SB Feuille(YF) FLW EB ApexTal(YAT) apex(YA) EB
        
        if (Surfoliairetotale[X.id_plante]>SENSETALLAGE):
          #print('test2')
          #deuxiemede = random.random()*5.
          deuxiemede = alea2[alea1_index[genotype]-1]*5#random.random()*STOPTALLAGE
          if (deuxiemede>=2):
            
            nb_talle[X.id_plante]=nb_talle[X.id_plante]+1
            Seuil[X.id_plante].append(seuil)
            Tailfingain[X.id_plante].append([5.5,5.5])
            YP=ParamPhytomere(X.id_plante,nb_talle[X.id_plante],0)
            YF=ParamFeuille(0,0,0,id_plante=X.id_plante,id_talle=nb_talle[X.id_plante],id_rang=1,Ymax=Premiecroiss[X.id_plante],Taillefinalel = 0.8*Premiecroiss[X.id_plante],Taillefinaleg = 0.2*Premiecroiss[X.id_plante])
            Yb=ParambourgeonRoot(X.id_plante,nb_talle[X.id_plante],1)
            YAT=ParamApexTal(X.id_plante,nb_talle[X.id_plante],1)
            YA=ParamApex(X.id_plante,nb_talle[X.id_plante],1)
            produce SB phytomere(YP) RollR(95) GetHead(0, 0, 0) Entrenoeud bourgeonRoot(Yb) FLW SB Feuille(YF) FLW EB ApexTal(YAT) apex(YA) EB
          else:
            produce
        
      else:
        produce
        
    else:
      produce ApexTal(X)
  else:
    produce ApexTal(X)

racine(X):
  global les_racines,les_feuilles
  if X.axe_arret==0:
    feuille_test=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.feuil_ref+6)]
    if feuille_test!=[] and mtg.property('ParamFeuille').get(feuille_test[0]).Phase>=1 :
      X.axe_arret=1
    
  elif X.lateral_arret==0:
    feuille_test=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.feuil_ref+7)]
    if feuille_test!=[] and mtg.property('ParamFeuille').get(feuille_test[0]).Phase>=1:
      X.lateral_arret=1
    
    


bourgeonRoot(X):
  global num_pointe,TPS,les_feuilles,SB,groupe
  if groupe==1:
    feuille_du_phytomere=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang)][0]
    ordre=Order(Complex(feuille_du_phytomere)) #ordre de la talle
    
    
    #if ordre<=1:
    if X.nb_prod_root==0:
      feuille_reference=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang+ordre)]
      if feuille_reference!=[] and mtg.property('ParamFeuille').get(feuille_reference[0]).Phase>=1:
        num_pointe=num_pointe+1
        #if SB<0.1:
        #  if les_diametres==[]:
        #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)       #(2.3*SB+0.33)
        #  else:
        #    nb=len(les_diametres)+1  
        #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)         #nb*(2.3*SB+0.33-(sum(les_diametres)/nb))
        #else:
        #  nb=len(les_diametres)+1
        #  Diameter=P_diamMax#random.normalvariate(0.59,0.11)             #nb*(0.56-(sum(les_diametres)/nb))
        
        
        if SB[X.id_plante]<0.11:
          Diameter=0.63*(1+((0.11-SB[X.id_plante])/0.11))*((SB[X.id_plante]+0.11)/(2*0.11))**2
        else:
          Diameter=0.63
        #Diameter=0.58
        
        #Diameter=0.63
        les_diametres.append(Diameter)
        #print('diametres',les_diametres)
        X.nb_prod_root=1
        Y=pte(id_pointe=num_pointe,id_plante=X.id_plante,age=0,diametre=Diameter,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]),isaxe=True)
        Y2=ParamRacine(age=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang,feuil_ref=X.id_rang+ordre)
        produce bourgeonRoot(X) FLW SB() racine(Y2) SetHead(0.,0.,-1.,-1.,0.,0.) tip(Y) FLW EB()
      else:
        produce bourgeonRoot(X)
        
        
    elif X.nb_prod_root==1:
      if ordre==0:
        feuille_reference=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang+1)]
      else:
        feuille_reference=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang+ordre+1)]
      if feuille_reference!=[] and mtg.property('ParamFeuille').get(feuille_reference[0]).Phase>=1:
        num_pointe=num_pointe+1
        #if SB<0.1:
        #  if les_diametres==[]:
        #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)          #(2.3*SB+0.33)
        #  else:
        #    nb=len(les_diametres)+1  
        #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)            #nb*(2.3*SB+0.33-(sum(les_diametres)/nb))
        #else:
        #  nb=len(les_diametres)+1
        #  Diameter=P_diamMax#random.normalvariate(0.59,0.11)             #nb*(0.56-(sum(les_diametres)/nb))
        
        if SB[X.id_plante]<0.11:
          Diameter=0.63*(1+((0.11-SB[X.id_plante])/0.11))*((SB[X.id_plante]+0.11)/(2*0.11))**2
        else:
          Diameter=0.63
        #Diameter=0.58
        
        les_diametres.append(Diameter)
        X.nb_prod_root=2
        Y=pte(id_pointe=num_pointe,id_plante=X.id_plante,age=0,diametre=Diameter,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]),isaxe=True)
        Y2=ParamRacine(age=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang,feuil_ref=X.id_rang+ordre+1)
        produce FLW SB() racine(Y2)  SetHead(0.,0.,-1.,-1.,0.,0.) tip(Y) FLW EB()
      else:
        produce bourgeonRoot(X)
    
    #else:
    #  if X.nb_prod_root==0:
    #    feuille_reference=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang+(ordre-1))]
    #    if feuille_reference!=[] and mtg.property('ParamFeuille').get(feuille_reference[0]).Phase>=1:
    #      num_pointe=num_pointe+1
    #      #if SB<0.1:
    #      #  if les_diametres==[]:
    #      #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)          #(2.3*SB+0.33)
    #      #  else:
    #      #    nb=len(les_diametres)+1  
    #      #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)           #nb*(2.3*SB+0.33-(sum(les_diametres)/nb))
    #      #else:
    #      #  nb=len(les_diametres)+1
    #      #  Diameter=P_diamMax#random.normalvariate(0.59,0.11)            #nb*(0.56-(sum(les_diametres)/nb))
    #      
    #      if SB[X.id_plante]<0.11:
    #        Diameter=0.63*(1+((0.11-SB[X.id_plante])/0.11))*((SB[X.id_plante]+0.11)/(2*0.11))**2
    #      else:
    #        Diameter=0.63
    #      
    #      les_diametres.append(Diameter)
    #      X.nb_prod_root=1
    #      Y=pte(id_pointe=num_pointe,id_plante=X.id_plante,age=0,diametre=Diameter,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]))
    #      Y2=ParamRacine(age=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang)
    #      produce bourgeonRoot(X) FLW SB() racine(Y2)  SetHead(0.,0.,-1.,-1.,0.,0.) tip(Y)  FLW EB()
    #    else:
    #      produce bourgeonRoot(X)
    #      
    #  elif X.nb_prod_root==1:
    #    feuille_reference=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang+ordre)]
    #    if feuille_reference!=[] and mtg.property('ParamFeuille').get(feuille_reference[0]).Phase>=1:
    #      num_pointe=num_pointe+1
    #      #if SB<0.1:
    #      #  if les_diametres==[]:
    #      #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)          #(2.3*SB+0.33)
    #      #  else:
    #      #    nb=len(les_diametres)+1  
    #      #    Diameter=P_diamMax#random.normalvariate(0.59,0.11)            #nb*(2.3*SB+0.33-(sum(les_diametres)/nb))
    #      #else:
    #      #  nb=len(les_diametres)+1
    #      #  Diameter=P_diamMax#random.normalvariate(0.59,0.11)             #nb*(0.56-(sum(les_diametres)/nb))
    #      
    #      if SB[X.id_plante]<0.11:
    #        Diameter=0.63*(1+((0.11-SB[X.id_plante])/0.11))*((SB[X.id_plante]+0.11)/(2*0.11))**2
    #      else:
    #        Diameter=0.63
    #      
    #      
    #      les_diametres.append(Diameter)
    #      X.nb_prod_root=2
    #      Y=pte(id_pointe=num_pointe,id_plante=X.id_plante,age=0,diametre=Diameter,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]))
    #      Y2=ParamRacine(age=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang)
    #      produce FLW SB() racine(Y2)  SetHead(0.,0.,-1.,-1.,0.,0.) tip(Y) FLW EB()
    #    else:
    #      produce bourgeonRoot(X)
    
    if X.nb_prod_root==2:
      produce
    
    
    
    
    
    
    
    
    
    #if ordre<=1:
    #  feuille_reference=feuille_du_phytomere
    #  if mtg.property('ParamFeuille').get(feuille_reference).Phase>=1:
    #    num_pointe=num_pointe+1
    #    if SB<0.1:
    #      if les_diametres==[]:
    #        Diameter=P_diamMax       #(2.3*SB+0.33)
    #      else:
    #        nb=len(les_diametres)+1
    #        Diameter=P_diamMax         #nb*(2.3*SB+0.33-(sum(les_diametres)/nb))
    #    else:
    #      nb=len(les_diametres)+1
    #      Diameter=P_diamMax          #nb*(0.56-(sum(les_diametres)/nb))
    #    les_diametres.append(Diameter)
    #    Y=pte(id_pointe=num_pointe,age=0,diametre=Diameter,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]))
    #    Y2=ParamRacine(age=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang)
    #    produce FLW SB() racine(Y2) IN SB() SetHead(0.,0.,-1.,-1.,0.,0.) tip(Y) IN EB() FLW EB()
    #  else:
    #    produce bourgeonRoot(X)
    #else:
    #  feuille_reference=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang+(ordre-1))]
    #  if feuille_reference!=[] and mtg.property('ParamFeuille').get(feuille_reference[0]).Phase>=1:
    #    num_pointe=num_pointe+1
    #    
    #    if SB<0.1:
    #      nb=len(les_diametres)+1
    #      Diameter=P_diamMax   #nb*(2.3*SB+0.33-(sum(les_diametres)/nb))#*0.9  
    #    else:
    #      nb=len(les_diametres)+1
    #      Diameter=P_diamMax   #nb*(0.56-(sum(les_diametres)/nb))#*0.9  
    #    les_diametres.append(Diameter)
    #    Y=pte(id_pointe=num_pointe,age=0,diametre=Diameter,Tortue=np.array([[0.,0.,-1],[0.,1,0],[-1.,0.,0.]]))
    #    Y2=ParamRacine(age=0,id_plante=X.id_plante,id_talle=X.id_talle,id_rang=X.id_rang)
    #    produce FLW SB() racine(Y2) IN SB() SetHead(0.,0.,-1.,-1.,0.,0.) tip(Y) IN EB() FLW EB()
    #  else:
    #    produce bourgeonRoot(X)
    #  produce bourgeonRoot(X)
  else:
    produce bourgeonRoot(X)



tip(X):
  global mtg,num_primordium,les_pointes,RootPotentialNewBiomass,PourcentageRootGrowthRealized,groupe,TPS_expe
  if groupe==1 and not X.arretee:
    X.age=X.age+dt
    for x in les_pointes:
      if x[0]==X.id_pointe:
        vertex_pointe=x[1]
        break
    
    vertex_racine=Complex(vertex_pointe)
    if X.isaxe and mtg.property('ParamRacine').get(vertex_racine).axe_arret==1:
      X.arretee=True
    elif not X.isaxe and mtg.property('ParamRacine').get(vertex_racine).lateral_arret==1:
      X.arretee=True
    #vertex_axe=Axis(vertex_pointe)
    
    #plante=Complex(vertex_pointe,2)
    ID_plante=X.id_plante
    pourcentage=PourcentageRootGrowthRealized[ID_plante]
    
    if X.arretee==False and X.senile==False and X.diametre>P_diamMin:
      profondeur=X.posO[2]
      PotentielCroissance=CroissanceRacine2(X,profondeur)
      RootPotentialNewBiomass[ID_plante]+=P_RootMasseVolumique*(pi*(X.diametre/2)*(X.diametre/2)*PotentielCroissance)
      elongation=PotentielCroissance*pourcentage
      X.longueur=X.longueur+elongation
      
      distInterRamif=P_distRamif * float(Sol[Couche(profondeur)][1])
      
      init=1
      
      while X.longueur > distInterRamif:
        
        (X.Tortue,X.posO)=Gravitropisme(vertex_pointe,X.segment,profondeur,longSegNorm,init)
        if X.segment==0:
          X.segment=1
        Z=seg(TPS,X.diametre,distInterRamif,X.id_pointe)
        nproduce SetHead(X.Tortue[0][0],X.Tortue[1][0],X.Tortue[2][0],X.Tortue[0][2],X.Tortue[1][2],X.Tortue[2][2])segment(Z)
        diam=tireDiamPointeFille(X.diametre)
        num_primordium=num_primordium+1
        param=primord(id_primord=num_primordium,age=0,diametre=diam,Tortue=X.Tortue,id_pointe_axe=X.id_pointe,posO=X.posO)
        nproduce Site(param)
        X.longueur=X.longueur-distInterRamif
        init=0
    
    #if X.senile==False and TPS>10 and X.arretee==False:
    #  
    #  racine=Complex(vertex_pointe)
    #  elements=Components(racine)
    #  if elements[len(elements)-1]==vertex_pointe:   #C est la pointe d un axe
    #    phyto=Complex(racine)
    #    ordre=Order(phyto)
    #    #print([Label(x) for x in Components(phyto)])
    #    feuille_associe=[x for x in Components(phyto) if Class(x)=='F'][0]
    #    if ordre==0:
    #      comp=0
    #    else:
    #      comp=ordre-1
    #    
    #    #feuille_reference=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==mtg.property('ParamFeuille').get(feuille_associe).id_plante and mtg.property('ParamFeuille') .get(x).id_talle==mtg.property('ParamFeuille').get(feuille_associe).id_talle and mtg.property('ParamFeuille').get(x).id_rang==mtg.property('ParamFeuille').get(feuille_associe).id_rang+comp+4)]
    #    #if feuille_reference!=[] and mtg.property('ParamFeuille').get(feuille_reference[0]).Phase==1:
    #    #  X.arretee=True
    #  #else:   # c'est la pointe d'une laterale
    #  #  if X.age > (P_penteDureeVieDiamTMD*X.diametre*P_TMD):
    #  #    X.arretee=True
    #  
    #  #if X.senile==False and TPS>10 and :
    #  #  X.senile=True    ### la pointe devient sénile
    #  
    #  #if X.senile==True:  ## on teste si tout l'axe est mort
    #  #  base_axe=vertex_axe[0]
    #  #  les_pointes_axe=Extremities(base_axe)
    #  #  X.axe_mort=True
    #  #  for x in les_pointes_axe:
    #  #    if mtg.property('pte').get(x).senile==False:
    #  #      X.axe_mort=False
    #  
    #for i in TPS_expe:
    #  if TPS==i-2:
    #    nproduce GetPos(0,0,0)
    nproduce tip(X)
    produce
  else:
    for i in TPS_expe:
      if TPS==i-2:
        nproduce GetPos(0,0,0)
    produce tip(X)


Site(X):
  global num_pointe,les_pointes,groupe
  if groupe==1:
    
    #if mtg.property('pte').get(vertex_pointe).axe_mort:
    #  produce
    if X.diametre < P_diamMin:
      produce 
    elif X.age < P_ageMaturitePointe:
      X.age=X.age+dt
    else:
      num_pointe=num_pointe+1
      Y=pte(id_pointe=num_pointe,age=0,Tortue=X.Tortue,diametre=X.diametre,posO=X.posO)
      produce SB() tip(Y) EB()
  
  else:
    produce Site(X)


#segment(X):
#  global les_pointes,Rootbiom
#  vertex_pointe=0
#  Rootbiom=Rootbiom+P_RootMasseVolumique*(pi*(X.diametre/2)*(X.diametre/2)*X.longueur)
#  
#  for x in les_pointes:
#    if mtg.property('pte').get(x).id_pointe==X.id_pointe_axe:
#      vertex_pointe=x
#      break
#  if mtg.property('pte').get(vertex_pointe).axe_mort:
#    nproduce
#  else:
#    nproduce segment(X)
#  produce


interpretation:

phytomere(X):
  produce Right(X.angletal)

Feuille(X):
  global Surfoliairetotale,Surfoliaireencours,les_feuilles
  if groupe==1:
    couleur = 2
    surfacefeuille = 0
    
    if (X.Phase==0):
      numsteps=(X.Taillefeuille-X.coupe)/LSTEP
      for i in xrange(int(numsteps)):
        taille = X.Taillefeuille
        L0 = X.Taillefinalel-taille
        if (i<((taille-Taillepointelineraire)/LSTEP)):
          #global large
          large=(-1.38*pow(((L0+(i*LSTEP))/X.Taillefinalel), 2)+0.66*((L0+(i*LSTEP))/X.Taillefinalel)+0.903)*(((1.9645*log(X.Ymax))-5.701)/2)
        else:
          largini=(-1.38*pow(((L0+((i-1)*LSTEP))/X.Taillefinalel), 2)+0.66*((L0+((i-1)*LSTEP))/X.Taillefinalel)+0.903)*(((1.9645*log(X.Ymax))-5.701)/2)
          #global large
          large=largini-((i-((taille-Taillepointelineraire)/LSTEP))*((largini*LSTEP)/Taillepointelineraire))
          
        if(i<(10/LSTEP)):
          rank=X.id_rang
          #global large
          if large<=0:
            large=0.01
          nproduce  StartGC() SetContour(limbo) SetWidth(large)SetColor(couleur)Down(Torsiongaine*pow(-1,rank))F(LSTEP)EndGC()
        
        if(i>(10/LSTEP)):
          #global large
          if large<=0:
            large=0.01
          nproduce StartGC() SetContour(limbo)SetWidth(large)SetColor(couleur)F(LSTEP)EndGC()
      produce
    
    
    
    if (X.Phase>0):
      vtx_feuille=[x for x in les_feuilles if (mtg.property('ParamFeuille').get(x).id_plante==X.id_plante and mtg.property('ParamFeuille').get(x).id_talle==X.id_talle and mtg.property('ParamFeuille').get(x).id_rang==X.id_rang)][0]  # vertex de la feuille
      
      
      #angle de la talle qui ecarte la feuille
      nproduce Left(X.angletal) 
      
      if X.Cutstatus<2:
        numsteps = ceil((X.Taillefeuille)/LSTEP)
      else:
        numsteps = ceil((X.Taillegaine)/LSTEP)
      
      numstepsg = ceil((X.Taillegaine)/LSTEP)
      
      for i in xrange(int(numsteps)):
        if (i<numstepsg-1):
          rank = X.id_rang
          large = max((2/3.1415)*(1.9645*log(max(X.Taillegaine*5,1))-5.701),0.1)
          
          if(i<(10/LSTEP)):
            if(i==1):
              if large<=0:
                large=0.01
              nproduce SetWidth(large)SetContour(gaino)StartGC()SetColor(2)Down(Torsiongaine*pow(-1,rank))F(LSTEP)EndGC()
            else:
              if large<=0:
                large=0.01
              nproduce SetWidth(large)SetContour(gaino)StartGC()SetColor(2)Down(Torsiongaine*pow(-1,rank))F(LSTEP)EndGC() 
          else:
            if large<=0:
              large=0.01
            nproduce SetWidth(large)SetContour(gaino)StartGC()SetColor(2)F(LSTEP)EndGC()
        
        else:
          taille = X.Taillelimbe+X.coupe
          L0 = X.Taillefinalel-taille
          if ((i-numstepsg)<((taille-Taillepointelineraire)/LSTEP)):
            large = (-1.38*pow(((L0+((i-numstepsg)*LSTEP))/X.Taillefinalel), 2)+0.66*((L0+((i-numstepsg)*LSTEP))/X.Taillefinalel)+0.903)*(((1.9645*log(X.Ymax))-5.701)/2)
          else:
            a=pow(((L0+(((i-numstepsg)-1)*LSTEP))/X.Taillefinalel), 2)
            #print('feuille',X.id_plante,X.id_talle,X.id_rang,X.Taillefeuille,X.Ymax)
            b=log(X.Ymax)
            largini=(-1.38*pow(((L0+(((i-numstepsg)-1)*LSTEP))/X.Taillefinalel), 2)+0.66*((L0+(((i-numstepsg)-1)*LSTEP))/X.Taillefinalel)+0.903)*(((1.9645*log(X.Ymax))-5.701)/2)
            large=largini-(((i-numstepsg)-((taille-Taillepointelineraire)/LSTEP))*((largini*LSTEP)/Taillepointelineraire))
          
          if(i<numstepsg-1):
            large=0.
          
          surfacefeuille=surfacefeuille+large*2.*LSTEP
          #Surfoliaireencours=Surfoliaireencours+large*2.*LSTEP
          
          Agesenesc = 400+(X.Ymax/20)*30
          if(i==numstepsg):
            
            if X.id_rang>4:
              pseudotige=max([Tailfingain[X.id_plante][X.id_talle][x] for x in range(X.id_rang-3,X.id_rang-1)])
            else:
              pseudotige=Tailfingain[X.id_plante][X.id_talle][X.id_rang-1]
            
            if ( X.Taillegaine > pseudotige):
              nproduce StartGC() SetContour(limbo)Left(X.angleinsert)SetColor(couleur)F(LSTEP)EndGC()
            
          if (X.age<=Agesenesc):
            if ((i>numsteps-2) and X.coupe>2):         # /* Pour avoir cicatrice au bout feuille coupées */
              #global large
              if i<numstepsg:
                if X.Cutstatus==2:
                  large_temp = max((2/3.1415)*(1.9645*log(max(X.Taillegaine*5,1))-5.701),0.1)
                  if large_temp<=0:
                    large_temp=0.01
                  nproduce SetWidth(large_temp)SetContour(gaino)StartGC()SetColor(2)F(LSTEP)EndGC()
                else:
                  if large<=0:
                    large=0.01
                  nproduce StartGC() SetContour(limbo) SetWidth(large)RollR(0)Left(curve)SetColor(couleur)F(LSTEP)EndGC()
                
              else:
                if large<=0:
                  large=0.01
                nproduce StartGC() SetContour(limbo) SetWidth(large)RollR(0)Left(curve)SetColor(couleur)F(LSTEP)EndGC()
            
            if(X.id_rang==1 and X.id_talle>0):
              if (i>(X.TailleEmergence-2)/LSTEP):
                #global large
                if large<=0:
                  large=0.01
                nproduce StartGC() SetContour(limbo) SetWidth(large)RollR(0)Left(curve)SetColor(couleur)F(LSTEP)EndGC()
                
                
              if (i<(X.TailleEmergence-2)/LSTEP): 
                rank = X.id_rang
                
                if(i<(10/LSTEP)):
                  #global large
                  if large<=0:
                    large=0.01
                  nproduce  StartGC() SetContour(foldlimbo) SetWidth(large)SetColor(couleur)Down(Torsiongaine*pow(-1,rank))F(LSTEP)EndGC()
                  
                else:
                  #global large
                  if large<=0:
                    large=0.01
                  nproduce StartGC()SetContour(foldlimbo)SetWidth(large)SetColor(couleur)F(LSTEP)EndGC()
                  
            else:
              
              if X.id_rang>4:
                pseudotige=max([Tailfingain[X.id_plante][X.id_talle][x] for x in range(X.id_rang-3,X.id_rang-1)])
              else:
                pseudotige=Tailfingain[X.id_plante][X.id_talle][X.id_rang-1]
              
              
              if ( i > pseudotige/LSTEP ):
                #global large
                if i<numstepsg:
                  if X.Cutstatus==2:
                    large_temp = max((2/3.1415)*(1.9645*log(max(X.Taillegaine*5,1))-5.701),0.1)
                    if large_temp<=0:
                      large_temp=0.01
                    nproduce SetWidth(large_temp)SetContour(gaino)StartGC()SetColor(2)F(LSTEP)EndGC()
                  else:
                    if large<=0:
                      large=0.01
                    nproduce StartGC() SetContour(limbo) SetWidth(large)RollR(0)Left(curve)SetColor(couleur)F(LSTEP)EndGC()
                  
                else:
                  if large<=0:
                    large=0.01
                  nproduce StartGC() SetContour(limbo) SetWidth(large)RollR(0)Left(curve)SetColor(couleur)F(LSTEP)EndGC()
                
              if (i<pseudotige/LSTEP):
                rank = X.id_rang
                
                if(i<(10/LSTEP)):
                  #global large
                  if large<=0:
                    large=0.01
                  nproduce  StartGC() SetContour(foldlimbo) SetWidth(large)SetColor(couleur)Down(Torsiongaine*pow(-1,rank))F(LSTEP)EndGC()
                  
                else:
                  #global large
                  if large<=0:
                    large=0.01
                  nproduce StartGC()SetContour(foldlimbo)SetWidth(large)SetColor(23)F(LSTEP)EndGC()
                  
          # /* Pour avoir feuille courbe et "s'ouvre" que quand en dehors de la gaine precendete la plus grande */
          else:
            if (X.age>Agesenesc and X.age<=Agesenesc+50):
              #global large,curve
              #print("limite senescence")
              if large<=0:
                large=0.01
              nproduce StartGC() SetContour(limbo) SetWidth(large)Left(curve)SetColor(couleur)F(LSTEP)EndGC()
              
              
              
      produce

SegFeuille(X):
  produce SetColor(10)F(1)

apex(X):
  nproduce StartGC() SetColor(3) F(0.2) EndGC()

ApexTal(X):
  nproduce StartGC() SetColor(5) F(0.2) EndGC()

tip(X):
  if X.longueur<=0:
    nproduce StartGC()   SetColor(1)PglShape(Cone(X.diametre/2+0.2,0.1,True,16)) EndGC()
  else:
    nproduce StartGC()   SetColor(1)PglShape(Cone(X.diametre/2+0.2,X.longueur,True,16)) EndGC()

segment(Z):
  nproduce StartGC() SetWidth(Z.diametre/2+0.2)SetColor(1)F(Z.longueur)EndGC()


endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	context.options.setSelection('Module declaration',1)
	import openalea.plantgl.all as pgl
	profilelimbe = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.0864873, -1.28825, 1),(0.138172, -0.154037, 1),(0.134849, -0.160444, 1),(0.302985, -0.00246132, 1),(0.176901, 0.144132, 1),(0.149559, 0.150022, 1),(-0.0742404, 1.49117, 1)]) , 
	    )
	profilelimbe.name = "profilelimbe"
	profilefoldlimbe = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.202006, 0.250293, 1),(-0.262712, 0.243403, 1),(-0.285408, 0.179588, 1),(-0.166833, -0.0558834, 1),(0.238723, -0.168115, 1),(0.348058, 0.171371, 1),(0.33338, 0.337654, 1),(0.0711467, 0.435274, 1),(0.085187, 0.149124, 1),(0.0123227, 0.175151, 1)]) , 
	    )
	profilefoldlimbe.name = "profilefoldlimbe"
	profilegaine = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.407478, -0.0511938, 1),(-0.390245, -0.17963, 1),(-0.355, -0.3575, 1),(-0.0025, -0.4925, 1),(0.363333, -0.355, 1),(0.47, -5.58794e-009, 1),(0.349167, 0.3425, 1),(0.005, 0.455, 1),(-0.3275, 0.3625, 1),(-0.380592, 0.203264, 1),(-0.402904, 0.0550844, 1)]) , 
	    )
	profilegaine.name = "profilegaine"
	panel_0 = ({'active': True, 'visible': False, 'name': 'Curve2D'},[('Curve2D',profilelimbe),('Curve2D',profilefoldlimbe),('Curve2D',profilegaine)])
	parameterset = [panel_0,]
	context["__functions__"] = []
	context["__curves__"] = [('profilelimbe',profilelimbe),('profilefoldlimbe',profilefoldlimbe),('profilegaine',profilegaine),]
	context["__parameterset__"] = parameterset
	context["profilelimbe"] = profilelimbe
	context["profilefoldlimbe"] = profilefoldlimbe
	context["profilegaine"] = profilegaine
